<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Vue学习笔记"><meta name="keywords" content=""><meta name="author" content="SearchFor"><meta name="copyright" content="SearchFor"><title>Vue学习笔记 | SearchFor's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#邂逅Vuejs"><span class="toc-number">1.</span> <span class="toc-text">邂逅Vuejs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#遇见Vuejs"><span class="toc-number">1.1.</span> <span class="toc-text">遇见Vuejs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么学习Vuejs"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么学习Vuejs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单认识一下Vuejs"><span class="toc-number">1.1.2.</span> <span class="toc-text">简单认识一下Vuejs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-js安装"><span class="toc-number">1.2.</span> <span class="toc-text">Vue.js安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接CDN引入"><span class="toc-number">1.2.1.</span> <span class="toc-text">直接CDN引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下载和引入"><span class="toc-number">1.2.2.</span> <span class="toc-text">下载和引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPM安装"><span class="toc-number">1.2.3.</span> <span class="toc-text">NPM安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue初体验"><span class="toc-number">1.3.</span> <span class="toc-text">Vue初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-Vuejs"><span class="toc-number">1.3.1.</span> <span class="toc-text">Hello Vuejs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue列表显示"><span class="toc-number">1.3.2.</span> <span class="toc-text">Vue列表显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例：计数器"><span class="toc-number">1.3.3.</span> <span class="toc-text">案例：计数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue的MVVM"><span class="toc-number">1.4.</span> <span class="toc-text">Vue的MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue中的MVVM"><span class="toc-number">1.4.1.</span> <span class="toc-text">Vue中的MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计数器的MVVM"><span class="toc-number">1.4.2.</span> <span class="toc-text">计数器的MVVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue的options"><span class="toc-number">1.5.</span> <span class="toc-text">Vue的options</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Vue实例传入的options"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建Vue实例传入的options</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue的生命周期"><span class="toc-number">1.6.</span> <span class="toc-text">Vue的生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue基础语法"><span class="toc-number">2.</span> <span class="toc-text">Vue基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#插值语法"><span class="toc-number">2.1.</span> <span class="toc-text">插值语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mustache"><span class="toc-number">2.1.1.</span> <span class="toc-text">Mustache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-once"><span class="toc-number">2.1.2.</span> <span class="toc-text">v-once</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-html"><span class="toc-number">2.1.3.</span> <span class="toc-text">v-html</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-text"><span class="toc-number">2.1.4.</span> <span class="toc-text">v-text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-pre"><span class="toc-number">2.1.5.</span> <span class="toc-text">v-pre</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-cloak"><span class="toc-number">2.1.6.</span> <span class="toc-text">v-cloak</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绑定属性"><span class="toc-number">2.2.</span> <span class="toc-text">绑定属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind介绍"><span class="toc-number">2.2.1.</span> <span class="toc-text">v-bind介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind基础"><span class="toc-number">2.2.2.</span> <span class="toc-text">v-bind基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind语法糖"><span class="toc-number">2.2.3.</span> <span class="toc-text">v-bind语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind绑定class-一"><span class="toc-number">2.2.4.</span> <span class="toc-text">v-bind绑定class(一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind绑定class-二"><span class="toc-number">2.2.5.</span> <span class="toc-text">v-bind绑定class(二)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind绑定class-三"><span class="toc-number">2.2.6.</span> <span class="toc-text">v-bind绑定class(三)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind绑定style-一"><span class="toc-number">2.2.7.</span> <span class="toc-text">v-bind绑定style(一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-bind绑定style-二"><span class="toc-number">2.2.8.</span> <span class="toc-text">v-bind绑定style(二)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算属性"><span class="toc-number">2.3.</span> <span class="toc-text">计算属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是计算属性？"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是计算属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算属性的复杂操作"><span class="toc-number">2.3.2.</span> <span class="toc-text">计算属性的复杂操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算属性的setter和getter"><span class="toc-number">2.3.3.</span> <span class="toc-text">计算属性的setter和getter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算属性的缓存"><span class="toc-number">2.3.4.</span> <span class="toc-text">计算属性的缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件监听"><span class="toc-number">2.4.</span> <span class="toc-text">事件监听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件监听-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-on基础"><span class="toc-number">2.4.2.</span> <span class="toc-text">v-on基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-on参数"><span class="toc-number">2.4.3.</span> <span class="toc-text">v-on参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-on修饰符"><span class="toc-number">2.4.4.</span> <span class="toc-text">v-on修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件判断"><span class="toc-number">2.5.</span> <span class="toc-text">条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if、v-else-if、v-else"><span class="toc-number">2.5.1.</span> <span class="toc-text">v-if、v-else-if、v-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件渲染案例"><span class="toc-number">2.5.2.</span> <span class="toc-text">条件渲染案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例小问题"><span class="toc-number">2.5.3.</span> <span class="toc-text">案例小问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show"><span class="toc-number">2.5.4.</span> <span class="toc-text">v-show</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环遍历"><span class="toc-number">2.6.</span> <span class="toc-text">循环遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for遍历数组"><span class="toc-number">2.6.1.</span> <span class="toc-text">v-for遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for遍历对象"><span class="toc-number">2.6.2.</span> <span class="toc-text">v-for遍历对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件的key属性"><span class="toc-number">2.6.3.</span> <span class="toc-text">组件的key属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测数组更新"><span class="toc-number">2.6.4.</span> <span class="toc-text">检测数组更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阶段案例"><span class="toc-number">2.7.</span> <span class="toc-text">阶段案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图书购物车"><span class="toc-number">2.7.1.</span> <span class="toc-text">图书购物车</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现：HTML、CSS"><span class="toc-number">2.7.2.</span> <span class="toc-text">代码实现：HTML、CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现：JS代码"><span class="toc-number">2.7.3.</span> <span class="toc-text">代码实现：JS代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model"><span class="toc-number">2.8.</span> <span class="toc-text">v-model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表单绑定v-model"><span class="toc-number">2.8.1.</span> <span class="toc-text">表单绑定v-model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model原理"><span class="toc-number">2.8.2.</span> <span class="toc-text">v-model原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-radio"><span class="toc-number">2.8.3.</span> <span class="toc-text">v-model:radio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-checkbox"><span class="toc-number">2.8.4.</span> <span class="toc-text">v-model:checkbox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-select"><span class="toc-number">2.8.5.</span> <span class="toc-text">v-model:select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值绑定"><span class="toc-number">2.8.6.</span> <span class="toc-text">值绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修饰符"><span class="toc-number">2.8.7.</span> <span class="toc-text">修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组件化开发"><span class="toc-number">3.</span> <span class="toc-text">组件化开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识组件化"><span class="toc-number">3.1.</span> <span class="toc-text">认识组件化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是组件化？"><span class="toc-number">3.1.1.</span> <span class="toc-text">什么是组件化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue组件化思想"><span class="toc-number">3.1.2.</span> <span class="toc-text">Vue组件化思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册组件"><span class="toc-number">3.2.</span> <span class="toc-text">注册组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注册组件的基本步骤"><span class="toc-number">3.2.1.</span> <span class="toc-text">注册组件的基本步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册组件步骤解析"><span class="toc-number">3.2.2.</span> <span class="toc-text">注册组件步骤解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三步的解析"><span class="toc-number">3.2.3.</span> <span class="toc-text">第三步的解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件其他补充"><span class="toc-number">3.3.</span> <span class="toc-text">组件其他补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局组件和局部组件"><span class="toc-number">3.3.1.</span> <span class="toc-text">全局组件和局部组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父组件和子组件"><span class="toc-number">3.3.2.</span> <span class="toc-text">父组件和子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册组件语法糖"><span class="toc-number">3.3.3.</span> <span class="toc-text">注册组件语法糖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板的分离写法"><span class="toc-number">3.3.4.</span> <span class="toc-text">模板的分离写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件数据存放"><span class="toc-number">3.4.</span> <span class="toc-text">组件数据存放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#组件可以访问Vue实例数据吗"><span class="toc-number">3.4.1.</span> <span class="toc-text">组件可以访问Vue实例数据吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件数据的存放"><span class="toc-number">3.4.2.</span> <span class="toc-text">组件数据的存放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是一个函数呢？"><span class="toc-number">3.4.3.</span> <span class="toc-text">为什么是一个函数呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父子组件通信"><span class="toc-number">3.5.</span> <span class="toc-text">父子组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件的通信"><span class="toc-number">3.5.1.</span> <span class="toc-text">父子组件的通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父级向子级传递"><span class="toc-number">3.6.</span> <span class="toc-text">父级向子级传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#props基本用法"><span class="toc-number">3.6.1.</span> <span class="toc-text">props基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props数据验证"><span class="toc-number">3.6.2.</span> <span class="toc-text">props数据验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子级向父级传递"><span class="toc-number">3.7.</span> <span class="toc-text">子级向父级传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子级向父级传递-1"><span class="toc-number">3.7.1.</span> <span class="toc-text">子级向父级传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义事件代码"><span class="toc-number">3.7.2.</span> <span class="toc-text">自定义事件代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父子组件的访问"><span class="toc-number">3.8.</span> <span class="toc-text">父子组件的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件的访问方式：-children"><span class="toc-number">3.8.1.</span> <span class="toc-text">父子组件的访问方式： $children</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件的访问方式：-refs"><span class="toc-number">3.8.2.</span> <span class="toc-text">父子组件的访问方式： $refs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件的访问方式：-parent"><span class="toc-number">3.8.3.</span> <span class="toc-text">父子组件的访问方式： $parent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非父子组件通信"><span class="toc-number">3.8.4.</span> <span class="toc-text">非父子组件通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插槽slot"><span class="toc-number">3.9.</span> <span class="toc-text">插槽slot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译作用域"><span class="toc-number">3.9.1.</span> <span class="toc-text">编译作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用slot"><span class="toc-number">3.9.2.</span> <span class="toc-text">为什么使用slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何封装这类组件呢？slot"><span class="toc-number">3.9.3.</span> <span class="toc-text">如何封装这类组件呢？slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slot基本使用"><span class="toc-number">3.9.4.</span> <span class="toc-text">slot基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#具名插槽slot"><span class="toc-number">3.9.5.</span> <span class="toc-text">具名插槽slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域插槽：准备"><span class="toc-number">3.9.6.</span> <span class="toc-text">作用域插槽：准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域插槽：使用"><span class="toc-number">3.9.7.</span> <span class="toc-text">作用域插槽：使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模块化开发"><span class="toc-number">4.</span> <span class="toc-text">模块化开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要模块化"><span class="toc-number">4.1.</span> <span class="toc-text">为什么需要模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript原始功能"><span class="toc-number">4.1.1.</span> <span class="toc-text">JavaScript原始功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名函数的解决方案"><span class="toc-number">4.1.2.</span> <span class="toc-text">匿名函数的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用模块作为出口"><span class="toc-number">4.1.3.</span> <span class="toc-text">使用模块作为出口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS"><span class="toc-number">4.2.</span> <span class="toc-text">CommonJS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS-了解"><span class="toc-number">4.2.1.</span> <span class="toc-text">CommonJS(了解)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6的export指令"><span class="toc-number">4.3.</span> <span class="toc-text">ES6的export指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#export基本使用"><span class="toc-number">4.3.1.</span> <span class="toc-text">export基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导出函数或类"><span class="toc-number">4.3.2.</span> <span class="toc-text">导出函数或类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#export-default"><span class="toc-number">4.3.3.</span> <span class="toc-text">export default</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6的import指令"><span class="toc-number">4.4.</span> <span class="toc-text">ES6的import指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import使用"><span class="toc-number">4.4.1.</span> <span class="toc-text">import使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack详解"><span class="toc-number">5.</span> <span class="toc-text">Webpack详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识webpack"><span class="toc-number">5.1.</span> <span class="toc-text">认识webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是webpack？"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么是webpack？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端模块化"><span class="toc-number">5.1.2.</span> <span class="toc-text">前端模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和grunt-gulp的对比"><span class="toc-number">5.1.3.</span> <span class="toc-text">和grunt&#x2F;gulp的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack安装"><span class="toc-number">5.2.</span> <span class="toc-text">webpack安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack安装-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">webpack安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack起步"><span class="toc-number">5.3.</span> <span class="toc-text">webpack起步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#准备工作"><span class="toc-number">5.3.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js文件的打包"><span class="toc-number">5.3.2.</span> <span class="toc-text">js文件的打包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack配置"><span class="toc-number">5.4.</span> <span class="toc-text">webpack配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#入口和出口"><span class="toc-number">5.4.1.</span> <span class="toc-text">入口和出口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部安装webpack"><span class="toc-number">5.4.2.</span> <span class="toc-text">局部安装webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json中定义启动"><span class="toc-number">5.4.3.</span> <span class="toc-text">package.json中定义启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css-loader的使用"><span class="toc-number">5.5.</span> <span class="toc-text">css-loader的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是loader？"><span class="toc-number">5.5.1.</span> <span class="toc-text">什么是loader？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css文件处理-准备工作"><span class="toc-number">5.5.2.</span> <span class="toc-text">css文件处理 - 准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css文件处理-–-打包报错信息"><span class="toc-number">5.5.3.</span> <span class="toc-text">css文件处理 – 打包报错信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css文件处理-–-css-loader"><span class="toc-number">5.5.4.</span> <span class="toc-text">css文件处理 – css-loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css文件处理-–-style-loader"><span class="toc-number">5.5.5.</span> <span class="toc-text">css文件处理 – style-loader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less文件处理"><span class="toc-number">5.6.</span> <span class="toc-text">less文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#less文件处理-–-准备工作"><span class="toc-number">5.6.1.</span> <span class="toc-text">less文件处理 – 准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less文件处理-–-less-loader"><span class="toc-number">5.6.2.</span> <span class="toc-text">less文件处理 – less-loader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片文件处理"><span class="toc-number">5.7.</span> <span class="toc-text">图片文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图片文件处理-–-资源准备阶段"><span class="toc-number">5.7.1.</span> <span class="toc-text">图片文件处理 – 资源准备阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片文件处理-–-url-loader"><span class="toc-number">5.7.2.</span> <span class="toc-text">图片文件处理 – url-loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片文件处理-–-file-loader"><span class="toc-number">5.7.3.</span> <span class="toc-text">图片文件处理 – file-loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片文件处理-–-修改文件名称"><span class="toc-number">5.7.4.</span> <span class="toc-text">图片文件处理 – 修改文件名称</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babel的使用"><span class="toc-number">5.8.</span> <span class="toc-text">babel的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6语法处理"><span class="toc-number">5.8.1.</span> <span class="toc-text">ES6语法处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack配置vue"><span class="toc-number">5.9.</span> <span class="toc-text">webpack配置vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入vue-js"><span class="toc-number">5.9.1.</span> <span class="toc-text">引入vue.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打包项目-–-错误信息"><span class="toc-number">5.9.2.</span> <span class="toc-text">打包项目 – 错误信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#el和template区别（一）"><span class="toc-number">5.9.3.</span> <span class="toc-text">el和template区别（一）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#el和template区别（二）"><span class="toc-number">5.9.4.</span> <span class="toc-text">el和template区别（二）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue组件化开发引入"><span class="toc-number">5.9.5.</span> <span class="toc-text">Vue组件化开发引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue文件封装处理"><span class="toc-number">5.9.6.</span> <span class="toc-text">.vue文件封装处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugin的使用"><span class="toc-number">5.10.</span> <span class="toc-text">plugin的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识plugin"><span class="toc-number">5.10.1.</span> <span class="toc-text">认识plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加版权的Plugin"><span class="toc-number">5.10.2.</span> <span class="toc-text">添加版权的Plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打包html的plugin"><span class="toc-number">5.10.3.</span> <span class="toc-text">打包html的plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js压缩的Plugin"><span class="toc-number">5.10.4.</span> <span class="toc-text">js压缩的Plugin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地服务器"><span class="toc-number">5.11.</span> <span class="toc-text">本地服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#搭建本地服务器"><span class="toc-number">5.11.1.</span> <span class="toc-text">搭建本地服务器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-CLI相关"><span class="toc-number">6.</span> <span class="toc-text">Vue CLI相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-CLI"><span class="toc-number">6.1.</span> <span class="toc-text">Vue CLI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Vue-CLI"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是Vue CLI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-CLI使用前提-Node"><span class="toc-number">6.1.2.</span> <span class="toc-text">Vue CLI使用前提 - Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-CLI使用前提-Webpack"><span class="toc-number">6.1.3.</span> <span class="toc-text">Vue CLI使用前提 - Webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-CLI的使用"><span class="toc-number">6.1.4.</span> <span class="toc-text">Vue CLI的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-CLI2"><span class="toc-number">6.2.</span> <span class="toc-text">Vue CLI2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-CLI2详解"><span class="toc-number">6.2.1.</span> <span class="toc-text">Vue CLI2详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录结构详解"><span class="toc-number">6.2.2.</span> <span class="toc-text">目录结构详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-Compiler和Runtime-only的区别"><span class="toc-number">6.2.3.</span> <span class="toc-text">Runtime-Compiler和Runtime-only的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render和template"><span class="toc-number">6.2.4.</span> <span class="toc-text">render和template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue程序运行过程"><span class="toc-number">6.2.5.</span> <span class="toc-text">Vue程序运行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render函数的使用"><span class="toc-number">6.2.6.</span> <span class="toc-text">render函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-run-build"><span class="toc-number">6.2.7.</span> <span class="toc-text">npm run build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-run-dev"><span class="toc-number">6.2.8.</span> <span class="toc-text">npm run dev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改配置：webpack-base-conf-js起别名"><span class="toc-number">6.2.9.</span> <span class="toc-text">修改配置：webpack.base.conf.js起别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-CLI3"><span class="toc-number">6.3.</span> <span class="toc-text">Vue CLI3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识Vue-CLI3"><span class="toc-number">6.3.1.</span> <span class="toc-text">认识Vue CLI3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-CLI3-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">Vue CLI3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录结构详解-1"><span class="toc-number">6.3.3.</span> <span class="toc-text">目录结构详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置去哪里了？"><span class="toc-number">6.3.4.</span> <span class="toc-text">配置去哪里了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义配置：起别名"><span class="toc-number">6.3.5.</span> <span class="toc-text">自定义配置：起别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-router详解"><span class="toc-number">7.</span> <span class="toc-text">vue-router详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识路由"><span class="toc-number">7.1.</span> <span class="toc-text">认识路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是路由"><span class="toc-number">7.1.1.</span> <span class="toc-text">什么是路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后端路由阶段"><span class="toc-number">7.1.2.</span> <span class="toc-text">后端路由阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端路由阶段"><span class="toc-number">7.1.3.</span> <span class="toc-text">前端路由阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端路由的规则"><span class="toc-number">7.2.</span> <span class="toc-text">前端路由的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL的hash"><span class="toc-number">7.2.1.</span> <span class="toc-text">URL的hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5的history模式：pushState"><span class="toc-number">7.2.2.</span> <span class="toc-text">HTML5的history模式：pushState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5的history模式：replaceState"><span class="toc-number">7.2.3.</span> <span class="toc-text">HTML5的history模式：replaceState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5的history模式：go"><span class="toc-number">7.2.4.</span> <span class="toc-text">HTML5的history模式：go</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router基础"><span class="toc-number">7.3.</span> <span class="toc-text">vue-router基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识vue-router"><span class="toc-number">7.3.1.</span> <span class="toc-text">认识vue-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装和使用vue-router"><span class="toc-number">7.3.2.</span> <span class="toc-text">安装和使用vue-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建router实例"><span class="toc-number">7.3.3.</span> <span class="toc-text">创建router实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂载到Vue实例中"><span class="toc-number">7.3.4.</span> <span class="toc-text">挂载到Vue实例中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤一：创建路由组件"><span class="toc-number">7.3.5.</span> <span class="toc-text">步骤一：创建路由组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤二：配置组件和路径的映射关系"><span class="toc-number">7.3.6.</span> <span class="toc-text">步骤二：配置组件和路径的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤三：使用路由"><span class="toc-number">7.3.7.</span> <span class="toc-text">步骤三：使用路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最终效果如下"><span class="toc-number">7.3.8.</span> <span class="toc-text">最终效果如下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#细节处理"><span class="toc-number">7.4.</span> <span class="toc-text">细节处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#路由的默认路径"><span class="toc-number">7.4.1.</span> <span class="toc-text">路由的默认路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5的History模式"><span class="toc-number">7.4.2.</span> <span class="toc-text">HTML5的History模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-link补充"><span class="toc-number">7.4.3.</span> <span class="toc-text">router-link补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改linkActiveClass"><span class="toc-number">7.4.4.</span> <span class="toc-text">修改linkActiveClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由代码跳转"><span class="toc-number">7.4.5.</span> <span class="toc-text">路由代码跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态路由"><span class="toc-number">7.4.6.</span> <span class="toc-text">动态路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由懒加载"><span class="toc-number">7.5.</span> <span class="toc-text">路由懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识路由的懒加载"><span class="toc-number">7.5.1.</span> <span class="toc-text">认识路由的懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由懒加载的效果"><span class="toc-number">7.5.2.</span> <span class="toc-text">路由懒加载的效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒加载的方式"><span class="toc-number">7.5.3.</span> <span class="toc-text">懒加载的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由嵌套"><span class="toc-number">7.6.</span> <span class="toc-text">路由嵌套</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识嵌套路由"><span class="toc-number">7.6.1.</span> <span class="toc-text">认识嵌套路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套路由实现"><span class="toc-number">7.6.2.</span> <span class="toc-text">嵌套路由实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套默认路径"><span class="toc-number">7.6.3.</span> <span class="toc-text">嵌套默认路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导航守卫"><span class="toc-number">7.7.</span> <span class="toc-text">导航守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用导航守卫"><span class="toc-number">7.7.1.</span> <span class="toc-text">为什么使用导航守卫?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导航守卫使用"><span class="toc-number">7.7.2.</span> <span class="toc-text">导航守卫使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导航守卫补充"><span class="toc-number">7.7.3.</span> <span class="toc-text">导航守卫补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive"><span class="toc-number">7.8.</span> <span class="toc-text">keep-alive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive遇见vue-router"><span class="toc-number">7.8.1.</span> <span class="toc-text">keep-alive遇见vue-router</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传递参数"><span class="toc-number">7.9.</span> <span class="toc-text">传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#准备工作-1"><span class="toc-number">7.9.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传递参数的方式"><span class="toc-number">7.9.2.</span> <span class="toc-text">传递参数的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传递参数方式一"><span class="toc-number">7.9.3.</span> <span class="toc-text">传递参数方式一: </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传递参数方式二-JavaScript代码"><span class="toc-number">7.9.4.</span> <span class="toc-text">传递参数方式二: JavaScript代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取参数"><span class="toc-number">7.9.5.</span> <span class="toc-text">获取参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#route和-router是有区别的"><span class="toc-number">7.9.6.</span> <span class="toc-text">$route和$router是有区别的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tabbar练习"><span class="toc-number">7.10.</span> <span class="toc-text">tabbar练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TabBar实现思路"><span class="toc-number">7.10.1.</span> <span class="toc-text">TabBar实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TabBar实现思路-1"><span class="toc-number">7.10.2.</span> <span class="toc-text">TabBar实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-number">7.10.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vuex详解"><span class="toc-number">8.</span> <span class="toc-text">Vuex详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识Vuex"><span class="toc-number">8.1.</span> <span class="toc-text">认识Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex是做什么的"><span class="toc-number">8.1.1.</span> <span class="toc-text">Vuex是做什么的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管理什么状态呢"><span class="toc-number">8.1.2.</span> <span class="toc-text">管理什么状态呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单界面的状态管理"><span class="toc-number">8.1.3.</span> <span class="toc-text">单界面的状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单界面状态管理的实现"><span class="toc-number">8.1.4.</span> <span class="toc-text">单界面状态管理的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多界面状态管理"><span class="toc-number">8.1.5.</span> <span class="toc-text">多界面状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex状态管理图例"><span class="toc-number">8.1.6.</span> <span class="toc-text">Vuex状态管理图例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex基本使用"><span class="toc-number">8.2.</span> <span class="toc-text">Vuex基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单的案例"><span class="toc-number">8.2.1.</span> <span class="toc-text">简单的案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂载到Vue实例中-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">挂载到Vue实例中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Vuex的count"><span class="toc-number">8.2.3.</span> <span class="toc-text">使用Vuex的count</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex核心概念"><span class="toc-number">8.3.</span> <span class="toc-text">Vuex核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex核心概念-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">Vuex核心概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#State"><span class="toc-number">8.4.</span> <span class="toc-text">State</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#State单一状态树"><span class="toc-number">8.4.1.</span> <span class="toc-text">State单一状态树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getters"><span class="toc-number">8.5.</span> <span class="toc-text">Getters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getters基本使用"><span class="toc-number">8.5.1.</span> <span class="toc-text">Getters基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Getters作为参数和传递参数"><span class="toc-number">8.5.2.</span> <span class="toc-text">Getters作为参数和传递参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutation"><span class="toc-number">8.6.</span> <span class="toc-text">Mutation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation状态更新"><span class="toc-number">8.6.1.</span> <span class="toc-text">Mutation状态更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation传递参数"><span class="toc-number">8.6.2.</span> <span class="toc-text">Mutation传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation提交风格"><span class="toc-number">8.6.3.</span> <span class="toc-text">Mutation提交风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation响应规则"><span class="toc-number">8.6.4.</span> <span class="toc-text">Mutation响应规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation常量类型-–-概念"><span class="toc-number">8.6.5.</span> <span class="toc-text">Mutation常量类型 – 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation常量类型-–-代码"><span class="toc-number">8.6.6.</span> <span class="toc-text">Mutation常量类型 – 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation同步函数"><span class="toc-number">8.6.7.</span> <span class="toc-text">Mutation同步函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Action"><span class="toc-number">8.7.</span> <span class="toc-text">Action</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Action的基本定义"><span class="toc-number">8.7.1.</span> <span class="toc-text">Action的基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action的分发"><span class="toc-number">8.7.2.</span> <span class="toc-text">Action的分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action返回的Promise"><span class="toc-number">8.7.3.</span> <span class="toc-text">Action返回的Promise</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module"><span class="toc-number">8.8.</span> <span class="toc-text">Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识Module"><span class="toc-number">8.8.1.</span> <span class="toc-text">认识Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Module局部状态"><span class="toc-number">8.8.2.</span> <span class="toc-text">Module局部状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Actions的写法"><span class="toc-number">8.8.3.</span> <span class="toc-text">Actions的写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目结构组织"><span class="toc-number">8.9.</span> <span class="toc-text">项目结构组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#项目结构"><span class="toc-number">8.9.1.</span> <span class="toc-text">项目结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise"><span class="toc-number">9.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识Promise"><span class="toc-number">9.1.</span> <span class="toc-text">认识Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Promise呢？"><span class="toc-number">9.1.1.</span> <span class="toc-text">什么是Promise呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络请求的回调地狱"><span class="toc-number">9.1.2.</span> <span class="toc-text">网络请求的回调地狱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise基本使用"><span class="toc-number">9.2.</span> <span class="toc-text">Promise基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器的异步事件"><span class="toc-number">9.2.1.</span> <span class="toc-text">定时器的异步事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器异步事件解析"><span class="toc-number">9.2.2.</span> <span class="toc-text">定时器异步事件解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise三种状态"><span class="toc-number">9.2.3.</span> <span class="toc-text">Promise三种状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise链式调用"><span class="toc-number">9.3.</span> <span class="toc-text">Promise链式调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise链式调用-1"><span class="toc-number">9.3.1.</span> <span class="toc-text">Promise链式调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链式调用简写"><span class="toc-number">9.3.2.</span> <span class="toc-text">链式调用简写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络模块封装"><span class="toc-number">10.</span> <span class="toc-text">网络模块封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模块的选择"><span class="toc-number">10.1.</span> <span class="toc-text">模块的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择什么网络模块"><span class="toc-number">10.1.1.</span> <span class="toc-text">选择什么网络模块?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jsonp封装"><span class="toc-number">10.2.</span> <span class="toc-text">jsonp封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp"><span class="toc-number">10.2.1.</span> <span class="toc-text">jsonp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP封装"><span class="toc-number">10.2.2.</span> <span class="toc-text">JSONP封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#认识axios"><span class="toc-number">10.3.</span> <span class="toc-text">认识axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么选择axios"><span class="toc-number">10.3.1.</span> <span class="toc-text">为什么选择axios?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axiox请求方式"><span class="toc-number">10.3.2.</span> <span class="toc-text">axiox请求方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送基本请求"><span class="toc-number">10.4.</span> <span class="toc-text">发送基本请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送get请求演示"><span class="toc-number">10.4.1.</span> <span class="toc-text">发送get请求演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送并发请求"><span class="toc-number">10.4.2.</span> <span class="toc-text">发送并发请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局配置"><span class="toc-number">10.4.3.</span> <span class="toc-text">全局配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的配置选项"><span class="toc-number">10.4.4.</span> <span class="toc-text">常见的配置选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios实例"><span class="toc-number">10.5.</span> <span class="toc-text">axios实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#axios的实例"><span class="toc-number">10.5.1.</span> <span class="toc-text">axios的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios封装"><span class="toc-number">10.5.2.</span> <span class="toc-text">axios封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拦截器"><span class="toc-number">10.6.</span> <span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用拦截器？"><span class="toc-number">10.6.1.</span> <span class="toc-text">如何使用拦截器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求拦截器中都做什么呢？"><span class="toc-number">10.6.2.</span> <span class="toc-text">请求拦截器中都做什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应拦截器中都做什么呢？"><span class="toc-number">10.6.3.</span> <span class="toc-text">响应拦截器中都做什么呢？</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">SearchFor</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://img.1ppt.com/uploads/allimg/1910/1_191025201728_1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SearchFor's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Vue学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>学习视频源：<a href="https://www.bilibili.com/video/av89760569" target="_blank" rel="noopener">https://www.bilibili.com/video/av89760569</a></p>
<h1 id="邂逅Vuejs"><a href="#邂逅Vuejs" class="headerlink" title="邂逅Vuejs"></a>邂逅Vuejs</h1><h2 id="遇见Vuejs"><a href="#遇见Vuejs" class="headerlink" title="遇见Vuejs"></a>遇见Vuejs</h2><h3 id="为什么学习Vuejs"><a href="#为什么学习Vuejs" class="headerlink" title="为什么学习Vuejs"></a>为什么学习Vuejs</h3><ul>
<li>可能你的公司正要将原有的项目使用Vue进行重构。</li>
<li>也可能是你的公司新项目决定使用Vue的技术栈。</li>
<li>当然，如果你现在正在换工作，你会发现招聘前端的需求中，10个有8个都对Vue有或多或少的要求。</li>
<li>当然，作为学习者我们知道Vuejs目前非常火，可以说是前端必备的一个技能。</li>
</ul>
<h3 id="简单认识一下Vuejs"><a href="#简单认识一下Vuejs" class="headerlink" title="简单认识一下Vuejs"></a>简单认识一下Vuejs</h3><p>（1）Vue是一个渐进式的框架，什么是渐进式的呢？<br>渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。<br>（2）Vue有很多特点和Web开发中常见的高级功能</p>
<ul>
<li>解耦视图和数据</li>
<li>可复用的组件</li>
<li>前端路由技术</li>
<li>状态管理</li>
<li>虚拟DOM</li>
</ul>
<h2 id="Vue-js安装"><a href="#Vue-js安装" class="headerlink" title="Vue.js安装"></a>Vue.js安装</h2><h3 id="直接CDN引入"><a href="#直接CDN引入" class="headerlink" title="直接CDN引入"></a>直接CDN引入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; </span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="下载和引入"><a href="#下载和引入" class="headerlink" title="下载和引入"></a>下载和引入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开发环境 https:&#x2F;&#x2F;vuejs.org&#x2F;js&#x2F;vue.js </span><br><span class="line">生产环境 https:&#x2F;&#x2F;vuejs.org&#x2F;js&#x2F;vue.min.js</span><br></pre></td></tr></table></figure>
<h3 id="NPM安装"><a href="#NPM安装" class="headerlink" title="NPM安装"></a>NPM安装</h3><p>后续通过webpack和CLI的使用，我们使用该方式。</p>
<h2 id="Vue初体验"><a href="#Vue初体验" class="headerlink" title="Vue初体验"></a>Vue初体验</h2><h3 id="Hello-Vuejs"><a href="#Hello-Vuejs" class="headerlink" title="Hello Vuejs"></a>Hello Vuejs</h3>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt><br>我们来做我们的第一个Vue程序，体验一下Vue的响应式<br><strong>代码做了什么事情？</strong><br>我们来阅读JavaScript代码，会发现创建了一个Vue对象。<br>创建Vue对象的时候，传入了一些options：{}</p>
<ul>
<li>{}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上</li>
<li>{}中包含了data属性：该属性中通常会存储一些数据<br>这些数据可以是我们直接定义出来的，比如像上面这样。<br>也可能是来自网络，从服务器加载的。</li>
</ul>
<p>浏览器执行代码的流程：</p>
<ul>
<li>执行到10~13行代码显示出对应的HTML</li>
<li>执行第16行代码创建Vue实例，并且对原HTML进行解析和修改。</li>
</ul>
<p>并且，目前我们的代码是可以做到响应式的。</p>
<h3 id="Vue列表显示"><a href="#Vue列表显示" class="headerlink" title="Vue列表显示"></a>Vue列表显示</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" alt></p>
<p>现在，我们来展示一个更加复杂的数据：数据列表。<br>比如我们现在从服务器请求过来一个列表<br>希望展示到HTML中。<br>HTML代码中，使用v-for指令<br>该指令我们后面会详细讲解，这里先学会使用。<br>是不是变得So Easy，我们再也不需要在JavaScript代码中完成DOM的拼接相关操作了<br>而且，更重要的是，它还是响应式的。<br>也就是说，当我们数组中的数据发生改变时，界面会自动改变。<br>依然让我们打开开发者模式的console，来试一下</p>
<h3 id="案例：计数器"><a href="#案例：计数器" class="headerlink" title="案例：计数器"></a>案例：计数器</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" alt><br>现在，我们来实现一个小的计数器<br>点击 + 计数器+1<br>点击 -  计数器 -1<br>这里，我们又要使用新的指令和属性了<br>新的属性：methods，该属性用于在Vue对象中定义方法。<br>新的指令：@click, 该指令用于监听某个元素的点击事件，并且需要指定当发生点击时，执行的方法（方法通常是methods中定义的方法）<br>你可能会疑惑？<br>这些@click是什么东西？<br>Vue对象中又是定义el/data/methods，到底都有哪些东西可以定义，以及它们的作用是什么？<br>这些疑惑在后续学习中都会一一解开。</p>
<h2 id="Vue的MVVM"><a href="#Vue的MVVM" class="headerlink" title="Vue的MVVM"></a>Vue的MVVM</h2><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><p>什么是MVVM呢？<br>通常我们学习一个概念，最好的方式是去看维基百科(对，千万别看成了百度百科)<br><a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MVVM</a><br>维基百科的官方解释，我们这里不再赘述。<br>我们直接来看Vue的MVVM<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" alt><br>View层：</p>
<ul>
<li>视图层</li>
<li>在我们前端开发中，通常就是DOM层。</li>
<li>主要的作用是给用户展示各种信息。</li>
</ul>
<p>Model层：</p>
<ul>
<li>数据层</li>
<li>数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。</li>
<li>在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。</li>
</ul>
<p>VueModel层：</p>
<ul>
<li>视图模型层</li>
<li>视图模型层是View和Model沟通的桥梁。</li>
<li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li>
<li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li>
</ul>
<h3 id="计数器的MVVM"><a href="#计数器的MVVM" class="headerlink" title="计数器的MVVM"></a>计数器的MVVM</h3><p>我们的计数器中就有严格的MVVM思想</p>
<ul>
<li>View依然是我们的DOM</li>
<li>Model就是我们我们抽离出来的obj</li>
<li>ViewModel就是我们创建的Vue对象实例</li>
</ul>
<p>它们之间如何工作呢？</p>
<ul>
<li>首先ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。</li>
<li>其次ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。</li>
</ul>
<p>有了Vue帮助我们完成VueModel层的任务，在后续的开发，我们就可以专注于数据的处理，以及DOM的编写工作了。</p>
<h2 id="Vue的options"><a href="#Vue的options" class="headerlink" title="Vue的options"></a>Vue的options</h2><h3 id="创建Vue实例传入的options"><a href="#创建Vue实例传入的options" class="headerlink" title="创建Vue实例传入的options"></a>创建Vue实例传入的options</h3><p>你会发现，我们在创建Vue实例的时候，传入了一个对象options。<br>这个options中可以包含哪些选项呢？<br>详细解析：<br><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE</a><br>目前掌握这些选项：<br>el: </p>
<ul>
<li>类型：<code>string | HTMLElement</code></li>
<li>作用：决定之后Vue实例会管理哪一个DOM。</li>
</ul>
<p>data: </p>
<ul>
<li>类型：<code>Object | Function</code> （组件当中data必须是一个函数）</li>
<li>作用：Vue实例对应的数据对象。</li>
</ul>
<p>methods: </p>
<ul>
<li>类型：<code>{ [key: string]: Function }</code></li>
<li>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" alt></li>
</ul>
<h1 id="Vue基础语法"><a href="#Vue基础语法" class="headerlink" title="Vue基础语法"></a>Vue基础语法</h1><h2 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h2><h3 id="Mustache"><a href="#Mustache" class="headerlink" title="Mustache"></a>Mustache</h3><p>如何将data中的文本数据，插入到HTML中呢？<br>我们已经学习过了，可以通过Mustache语法(也就是双大括号)。<br>Mustache: 胡子/胡须.<br>我们可以像下面这样来使用，并且数据是响应式的<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" alt></p>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>但是，在某些情况下，我们可能不希望界面随意的跟随改变<br>这个时候，我们就可以使用一个Vue的指令<br>v-once:<br>该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)<br>该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。<br>代码如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" alt></p>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">某些情况下，我们从服务器请求到的数据本身就是一个HTML代码</span><br><span class="line">如果我们直接通过&#123;&#123;&#125;&#125;来输出，会将HTML代码也一起输出。</span><br><span class="line">但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。</span><br><span class="line">如果我们希望解析出HTML展示</span><br><span class="line">可以使用v-html指令</span><br><span class="line">该指令后面往往会跟上一个string类型</span><br><span class="line">会将string的html解析出来并且进行渲染</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" alt></p>
<h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><p>v-text作用和Mustache比较相似：都是用于将数据显示在界面中<br>v-text通常情况下，接受一个string类型<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.png" alt></p>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。<br>比如下面的代码：</p>
<ul>
<li>第一个h2元素中的内容会被编译解析出来对应的内容</li>
<li>第二个h2元素中会直接显示</li>
</ul>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/19.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.png" alt></p>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签。<br>在vue解析之前，div中有一个属性v-cloak<br>在vue解析之后，div中没有一个属性v-cloak<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/21.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/22.png" alt></p>
<h2 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h2><h3 id="v-bind介绍"><a href="#v-bind介绍" class="headerlink" title="v-bind介绍"></a>v-bind介绍</h3><p>前面我们学习的指令主要作用是将值插入到我们模板的内容当中。<br>但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。<br>比如动态绑定a元素的href属性<br>比如动态绑定img元素的src属性<br>这个时候，我们可以使用v-bind指令：<br>作用：动态绑定属性<br>缩写：:<br>预期：any (with argument) | Object (without argument)<br>参数：attrOrProp (optional)</p>
<p>下面，我们就具体来学习v-bind的使用</p>
<h3 id="v-bind基础"><a href="#v-bind基础" class="headerlink" title="v-bind基础"></a>v-bind基础</h3><p>v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(这个学到组件时再介绍)<br>在开发中，有哪些属性需要动态进行绑定呢？<br>还是有很多的，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等<br>比如通过Vue实例中的data绑定元素的src和href，代码如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24.png" alt></p>
<h3 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a>v-bind语法糖</h3><p>v-bind有一个对应的语法糖，也就是简写方式<br>在开发中，我们通常会使用语法糖的形式，因为这样更加简洁。<br>简写方式如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.png" alt></p>
<h3 id="v-bind绑定class-一"><a href="#v-bind绑定class-一" class="headerlink" title="v-bind绑定class(一)"></a>v-bind绑定class(一)</h3><p>很多时候，我们希望动态的来切换class，比如：</p>
<ul>
<li>当数据为某个状态时，字体显示红色。</li>
<li>当数据另一个状态时，字体显示黑色。</li>
</ul>
<p>绑定class有两种方式：</p>
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
<h3 id="v-bind绑定class-二"><a href="#v-bind绑定class-二" class="headerlink" title="v-bind绑定class(二)"></a>v-bind绑定class(二)</h3><p>绑定方式：对象语法<br>对象语法的含义是:class后面跟的是一个对象。<br>对象语法有下面这些用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用法一：直接通过&#123;&#125;绑定一个类</span><br><span class="line">&lt;h2 :class&#x3D;&quot;&#123;&#39;active&#39;: isActive&#125;&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">用法二：也可以通过判断，传入多个值</span><br><span class="line">&lt;h2 :class&#x3D;&quot;&#123;&#39;active&#39;: isActive, &#39;line&#39;: isLine&#125;&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">用法三：和普通的类同时存在，并不冲突</span><br><span class="line">注：如果isActive和isLine都为true，那么会有title&#x2F;active&#x2F;line三个类</span><br><span class="line">&lt;h2 class&#x3D;&quot;title&quot; :class&#x3D;&quot;&#123;&#39;active&#39;: isActive, &#39;line&#39;: isLine&#125;&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">用法四：如果过于复杂，可以放在一个methods或者computed中</span><br><span class="line">注：classes是一个计算属性</span><br><span class="line">&lt;h2 class&#x3D;&quot;title&quot; :class&#x3D;&quot;classes&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
<h3 id="v-bind绑定class-三"><a href="#v-bind绑定class-三" class="headerlink" title="v-bind绑定class(三)"></a>v-bind绑定class(三)</h3><p>绑定方式：数组语法<br>数组语法的含义是:class后面跟的是一个数组。<br>数组语法有下面这些用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用法一：直接通过&#123;&#125;绑定一个类</span><br><span class="line">&lt;h2 :class&#x3D;&quot;[&#39;active&#39;]&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">用法二：也可以传入多个值</span><br><span class="line">&lt;h2 :class&#x3D;&quot;[&#39;active&#39;, &#39;line&#39;]&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">用法三：和普通的类同时存在，并不冲突</span><br><span class="line">注：会有title&#x2F;active&#x2F;line三个类</span><br><span class="line">&lt;h2 class&#x3D;&quot;title&quot; :class&#x3D;&quot;[&#39;active&#39;, &#39;line&#39;]&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">用法四：如果过于复杂，可以放在一个methods或者computed中</span><br><span class="line">注：classes是一个计算属性</span><br><span class="line">&lt;h2 class&#x3D;&quot;title&quot; :class&#x3D;&quot;classes&quot;&gt;Hello World&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
<h3 id="v-bind绑定style-一"><a href="#v-bind绑定style-一" class="headerlink" title="v-bind绑定style(一)"></a>v-bind绑定style(一)</h3><p>我们可以利用v-bind:style来绑定一些CSS内联样式。<br>在写CSS属性名的时候，比如font-size<br>我们可以使用驼峰式 (camelCase)  fontSize<br>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’<br>绑定class有两种方式：</p>
<ul>
<li>对象语法</li>
<li>数组语法</li>
</ul>
<h3 id="v-bind绑定style-二"><a href="#v-bind绑定style-二" class="headerlink" title="v-bind绑定style(二)"></a>v-bind绑定style(二)</h3><p>绑定方式一：对象语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:style&#x3D;&quot;&#123;color: currentColor, fontSize: fontSize + &#39;px&#39;&#125;&quot;</span><br><span class="line">style后面跟的是一个对象类型</span><br><span class="line">对象的key是CSS属性名称</span><br><span class="line">对象的value是具体赋的值，值可以来自于data中的属性</span><br></pre></td></tr></table></figure>
<p>绑定方式二：数组语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style&#x3D;&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">style后面跟的是一个数组类型</span><br><span class="line">多个值以，分割即可</span><br></pre></td></tr></table></figure>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="什么是计算属性？"><a href="#什么是计算属性？" class="headerlink" title="什么是计算属性？"></a>什么是计算属性？</h3><p>我们知道，在模板中可以直接通过插值语法显示一些data中的数据。<br>但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示<br>比如我们有firstName和lastName两个变量，我们需要显示完整的名称。<br>但是如果多个地方都需要显示完整的名称，我们就需要写多个 <br>我们可以将上面的代码换成计算属性：<br>OK，我们发现计算属性是写在实例的computed选项中的<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/28.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/29.png" alt></p>
<h3 id="计算属性的复杂操作"><a href="#计算属性的复杂操作" class="headerlink" title="计算属性的复杂操作"></a>计算属性的复杂操作</h3><p>计算属性中也可以进行一些更加复杂的操作，比如下面的例子：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.png" alt></p>
<h3 id="计算属性的setter和getter"><a href="#计算属性的setter和getter" class="headerlink" title="计算属性的setter和getter"></a>计算属性的setter和getter</h3><p>每个计算属性都包含一个getter和一个setter<br>在上面的例子中，我们只是使用getter来读取。<br>在某些情况下，你也可以提供一个setter方法（不常用）。<br>在需要写setter的时候，代码如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/31.png" alt></p>
<h3 id="计算属性的缓存"><a href="#计算属性的缓存" class="headerlink" title="计算属性的缓存"></a>计算属性的缓存</h3><p>我们可能会考虑这样的一个问题：</p>
<ul>
<li>methods和computed看起来都可以实现我们的功能，</li>
<li>那么为什么还要多一个计算属性这个东西呢？</li>
<li>原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</li>
</ul>
<p>我们来看下面的代码：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/32.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/33.png" alt></p>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><h3 id="事件监听-1"><a href="#事件监听-1" class="headerlink" title="事件监听"></a>事件监听</h3><p>在前端开发中，我们需要经常和用于交互。<br>这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等<br>在Vue中如何监听事件呢？使用v-on指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-on介绍</span><br><span class="line">作用：绑定事件监听器</span><br><span class="line">缩写：@</span><br><span class="line">预期：Function | Inline Statement | Object</span><br><span class="line">参数：event</span><br></pre></td></tr></table></figure>

<p>下面，我们就具体来学习v-on的使用。</p>
<h3 id="v-on基础"><a href="#v-on基础" class="headerlink" title="v-on基础"></a>v-on基础</h3><p>这里，我们用一个监听按钮的点击事件，来简单看看v-on的使用<br>下面的代码中，我们使用了v-on:click=”counter++”<br>另外，我们可以将事件指向一个在methods中定义的函数<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/34.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.png" alt><br>注：v-on也有对应的语法糖：<br>v-on:click可以写成@click<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/36.png" alt></p>
<h3 id="v-on参数"><a href="#v-on参数" class="headerlink" title="v-on参数"></a>v-on参数</h3><p>当通过methods中定义方法，以供@click调用时，需要注意参数问题：<br>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。<br>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去<br>情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/37.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/38.png" alt></p>
<h3 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a>v-on修饰符</h3><p>在某些情况下，我们拿到event的目的可能是进行一些事件处理。<br>Vue提供了修饰符来帮助我们方便的处理一些事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.stop - 调用 event.stopPropagation()。</span><br><span class="line">.prevent - 调用 event.preventDefault()。</span><br><span class="line">.&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。</span><br><span class="line">.native - 监听组件根元素的原生事件。</span><br><span class="line">.once - 只触发一次回调。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/39.png" alt></p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="v-if、v-else-if、v-else"><a href="#v-if、v-else-if、v-else" class="headerlink" title="v-if、v-else-if、v-else"></a>v-if、v-else-if、v-else</h3><p>这三个指令与JavaScript的条件语句if、else、else if类似。<br>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件<br>简单的案例演示：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/40.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/41.png" alt><br>v-if的原理：</p>
<ul>
<li>v-if后面的条件为false时，对应的元素以及其子元素不会渲染。</li>
<li>也就是根本没有不会有对应的标签出现在DOM中。</li>
</ul>
<h3 id="条件渲染案例"><a href="#条件渲染案例" class="headerlink" title="条件渲染案例"></a>条件渲染案例</h3><p>我们来做一个简单的小案例：<br>用户再登录时，可以切换使用用户账号登录还是邮箱地址登录。<br>类似如下情景：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/42.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/43.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/44.png" alt></p>
<h3 id="案例小问题"><a href="#案例小问题" class="headerlink" title="案例小问题"></a>案例小问题</h3><p>小问题：<br>如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。<br>但是按道理讲，我们应该切换到另外一个input元素中了。<br>在另一个input元素中，我们并没有输入内容。<br>为什么会出现这个问题呢？<br>问题解答：<br>这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。<br>在上面的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用了。<br>解决方案：<br>如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key<br>并且我们需要保证key的不同<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/45.png" alt></p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show的用法和v-if非常相似，也用于决定一个元素是否渲染：<br>v-if和v-show对比<br>v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？<br>v-if当条件为false时，压根不会有对应的元素在DOM中。<br>v-show当条件为false时，仅仅是将元素的display属性设置为none而已。<br>开发中如何选择呢？<br>当需要在显示与隐藏之间切片很频繁时，使用v-show<br>当只有一次切换时，通过使用v-if<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/46.png" alt></p>
<h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><h3 id="v-for遍历数组"><a href="#v-for遍历数组" class="headerlink" title="v-for遍历数组"></a>v-for遍历数组</h3><p>当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。<br>v-for的语法类似于JavaScript中的for循环。<br>格式如下：item in items的形式。</p>
<p>我们来看一个简单的案例：<br>如果在遍历的过程中不需要使用索引值<br>v-for=”movie in movies”<br>依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie<br>如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？<br>语法格式：v-for=(item, index) in items<br>其中的index就代表了取出的item在原数组的索引值。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/47.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/48.png" alt></p>
<h3 id="v-for遍历对象"><a href="#v-for遍历对象" class="headerlink" title="v-for遍历对象"></a>v-for遍历对象</h3><p>v-for可以用户遍历对象：<br>比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/49.png" alt></p>
<h3 id="组件的key属性"><a href="#组件的key属性" class="headerlink" title="组件的key属性"></a>组件的key属性</h3><p>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。<br>为什么需要这个key属性呢（了解）？<br>这个其实和Vue的虚拟DOM的Diff算法有关系。<br>这里我们借用React’s diff algorithm中的一张图来简单说明一下：<br>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点<br>我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。<br>即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？<br>所以我们需要使用key来给每个节点做一个唯一标识<br>Diff算法就可以正确的识别此节点<br>找到正确的位置区插入新的节点。<br>所以一句话，<strong>key的作用主要是为了高效的更新虚拟DOM</strong><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/50.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/51.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/52.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/53.png" alt></p>
<h3 id="检测数组更新"><a href="#检测数组更新" class="headerlink" title="检测数组更新"></a>检测数组更新</h3><p>因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。<br>Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/54.png" alt></p>
<h2 id="阶段案例"><a href="#阶段案例" class="headerlink" title="阶段案例"></a>阶段案例</h2><h3 id="图书购物车"><a href="#图书购物车" class="headerlink" title="图书购物车"></a>图书购物车</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/55.png" alt></p>
<h3 id="代码实现：HTML、CSS"><a href="#代码实现：HTML、CSS" class="headerlink" title="代码实现：HTML、CSS"></a>代码实现：HTML、CSS</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/56.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/57.png" alt></p>
<h3 id="代码实现：JS代码"><a href="#代码实现：JS代码" class="headerlink" title="代码实现：JS代码"></a>代码实现：JS代码</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/58.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/59.png" alt></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="表单绑定v-model"><a href="#表单绑定v-model" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h3><p>表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。<br>Vue中使用v-model指令来实现表单元素和数据的双向绑定。<br>案例的解析：<br>当我们在输入框输入内容时<br>因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。<br>当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。<br>所以，通过v-model实现了双向的绑定。<br>当然，我们也可以将v-model用于textarea元素<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/60.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/61.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/62.png" alt></p>
<h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><p>v-model其实是一个语法糖，它的背后本质上是包含两个操作：<br>1.v-bind绑定一个value属性<br>2.v-on指令给当前元素绑定input事件<br>也就是说下面的代码：等同于下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">等同于</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;message&quot; v-on:input&#x3D;&quot;message &#x3D; $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/63.png" alt></p>
<h3 id="v-model-radio"><a href="#v-model-radio" class="headerlink" title="v-model:radio"></a>v-model:radio</h3><p>当存在多个单选框时<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/64.png" alt></p>
<h3 id="v-model-checkbox"><a href="#v-model-checkbox" class="headerlink" title="v-model:checkbox"></a>v-model:checkbox</h3><p>复选框分为两种情况：单个勾选框和多个勾选框<br>单个勾选框：<br>v-model即为布尔值。<br>此时input的value并不影响v-model的值。<br>多个复选框：<br>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。<br>当选中某一个时，就会将input的value添加到数组中。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/65.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/66.png" alt></p>
<h3 id="v-model-select"><a href="#v-model-select" class="headerlink" title="v-model:select"></a>v-model:select</h3><p>和checkbox一样，select也分单选和多选两种情况。<br>单选：只能选中一个值。<br>v-model绑定的是一个值。<br>当我们选中option中的一个时，会将它对应的value赋值到mySelect中<br>多选：可以选中多个值。<br>v-model绑定的是一个数组。<br>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/67.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/68.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/69.png" alt></p>
<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><p>初看Vue官方值绑定的时候，我很疑惑：what the hell is that？<br>但是仔细阅读之后，发现很简单，就是动态的给value赋值而已：<br>我们前面的value中的值，可以回头去看一下，都是在定义input的时候直接给定的。<br>但是真实开发中，这些input的值可能是从网络获取或定义在data中的。<br>所以我们可以通过v-bind:value动态的给value绑定值。<br>这不就是v-bind吗？<br>这不就是v-bind在input中的应用吗？搞的我看了很久，搞不清他想讲什么。<br>这里不再给出对应的代码，因为会用v-bind，就会值绑定的应用了。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>lazy修饰符：<br>默认情况下，v-model默认是在input事件中同步输入框的数据的。<br>也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。<br>lazy修饰符可以让数据在失去焦点或者回车时才会更新：<br>number修饰符：<br>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。<br>但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。<br>number修饰符可以让在输入框中输入的内容自动转成数字类型：<br>trim修饰符：<br>如果输入的内容首尾有很多空格，通常我们希望将其去除<br>trim修饰符可以过滤内容左右两边的空格<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.png" alt></p>
<h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><h2 id="认识组件化"><a href="#认识组件化" class="headerlink" title="认识组件化"></a>认识组件化</h2><h3 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h3><p>人面对复杂问题的处理方式：<br>任何一个人处理信息的逻辑能力都是有限的<br>所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。<br>但是，我们人有一种天生的能力，就是将问题进行拆解。<br>如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。<br>组件化也是类似的思想：<br>如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。<br>但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/71.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/72.png" alt><br>我们将一个完整的页面分成很多个组件。<br>每个组件都用于实现页面的一个功能块。<br>而每一个组件又可以进行细分。</p>
<h3 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a>Vue组件化思想</h3><p>组件化是Vue.js中的重要思想<br>它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。<br>任何的应用都会被抽象成一颗组件树。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/73.png" alt><br>组件化思想的应用：<br>有了组件化的思想，我们在之后的开发中就要充分的利用它。<br>尽可能的将页面拆分成一个个小的、可复用的组件。<br>这样让我们的代码更加方便组织和管理，并且扩展性也更强。<br>所以，组件是Vue开发中，非常重要的一个篇章，要认真学习。</p>
<h2 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h2><h3 id="注册组件的基本步骤"><a href="#注册组件的基本步骤" class="headerlink" title="注册组件的基本步骤"></a>注册组件的基本步骤</h3><p>组件的使用分成三个步骤：</p>
<ul>
<li>创建组件构造器</li>
<li>注册组件</li>
<li>使用组件。</li>
</ul>
<p>我们来看看通过代码如何注册组件<br>查看运行结果：<br>和直接使用一个div看起来并没有什么区别。<br>但是我们可以设想，如果很多地方都要显示这样的信息，我们是不是就可以直接使用<code>&lt;my-cpn&gt;&lt;/my-cpn&gt;</code>来完成呢？<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/74.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/75.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/76.png" alt></p>
<h3 id="注册组件步骤解析"><a href="#注册组件步骤解析" class="headerlink" title="注册组件步骤解析"></a>注册组件步骤解析</h3><p>这里的步骤都代表什么含义呢？<br>1.Vue.extend()：<br>调用Vue.extend()创建的是一个组件构造器。<br>通常在创建组件构造器时，传入template代表我们自定义组件的模板。<br>该模板就是在使用到组件的地方，要显示的HTML代码。<br>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础。<br>2.Vue.component()：<br>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。<br>所以需要传递两个参数：1、注册组件的标签名 2、组件构造器<br>3.组件必须挂载在某个Vue实例下，否则它不会生效。（见下页）<br>我们来看下面我使用了三次<my-cpn></my-cpn><br>而第三次其实并没有生效：</p>
<h3 id="第三步的解析"><a href="#第三步的解析" class="headerlink" title="第三步的解析"></a>第三步的解析</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/77.png" alt></p>
<h2 id="组件其他补充"><a href="#组件其他补充" class="headerlink" title="组件其他补充"></a>组件其他补充</h2><h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h3><p>当我们通过调用Vue.component()注册组件时，组件的注册是全局的<br>这意味着该组件可以在任意Vue示例下使用。<br>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/78.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/79.png" alt></p>
<h3 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a>父组件和子组件</h3><p>在前面我们看到了组件树：<br>组件和组件之间存在层级关系<br>而其中一种非常重要的关系就是父子组件的关系<br>我们来看通过代码如何组成的这种层级关系：</p>
<p>父子组件错误用法：以子标签的形式在Vue实例中使用<br>因为当子组件注册到父组件的components时，Vue会编译好父组件的模块<br>该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）<br><code>&lt;child-cpn&gt;&lt;/child-cpn&gt;</code>是只能在父组件中被识别的。<br>类似这种用法，<code>&lt;child-cpn&gt;&lt;/child-cpn&gt;</code>是会被浏览器忽略的<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/80.png" alt></p>
<h3 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h3><p>在上面注册组件的方式，可能会有些繁琐。<br>Vue为了简化这个过程，提供了注册的语法糖。<br>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。<br><strong>语法糖注册全局组件和局部组件</strong><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/81.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/82.png" alt></p>
<h3 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h3><p>刚才，我们通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法。<br>如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。<br>Vue提供了两种方案来定义HTML模块内容：<br>使用<code>&lt;script&gt;</code>标签<br>使用<code>&lt;template&gt;</code>标签<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/83.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/84.png" alt></p>
<h2 id="组件数据存放"><a href="#组件数据存放" class="headerlink" title="组件数据存放"></a>组件数据存放</h2><h3 id="组件可以访问Vue实例数据吗"><a href="#组件可以访问Vue实例数据吗" class="headerlink" title="组件可以访问Vue实例数据吗?"></a>组件可以访问Vue实例数据吗?</h3><p>组件是一个单独功能模块的封装：<br>这个模块有属于自己的HTML模板，也应该有属性自己的数据data。<br>组件中的数据是保存在哪里呢？顶层的Vue实例中吗？<br>我们先来测试一下，组件中能不能直接访问Vue实例中的data<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/85.png" alt><br>我们发现不能访问，而且即使可以访问，如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿。<br>结论：Vue组件应该有自己保存数据的地方。</p>
<h3 id="组件数据的存放"><a href="#组件数据的存放" class="headerlink" title="组件数据的存放"></a>组件数据的存放</h3><p>组件自己的数据存放在哪里呢?<br>组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)<br>只是这个data属性必须是一个函数<br>而且这个函数返回一个对象，对象内部保存着数据<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/86.png" alt></p>
<h3 id="为什么是一个函数呢？"><a href="#为什么是一个函数呢？" class="headerlink" title="为什么是一个函数呢？"></a>为什么是一个函数呢？</h3><p>为什么data在组件中必须是一个函数呢?<br>首先，如果不是一个函数，Vue直接就会报错。<br>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/87.png" alt></p>
<h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><h3 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h3><p>在上一个小节中，我们提到了子组件是不能引用父组件或者Vue实例的数据的。<br>但是，在开发中，往往一些数据确实需要从上层传递到下层：<br>比如在一个页面中，我们从服务器请求到了很多的数据。<br>其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。<br>这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件)将数据传递给小组件(子组件)。<br>如何进行父子组件间的通信呢？Vue官方提到<br>通过props向子组件传递数据<br>通过事件向父组件发送消息</p>
<p>在下面的代码中，我直接将Vue实例当做父组件，并且其中包含子组件来简化代码。<br>真实的开发中，Vue实例和子组件的通信和父组件和子组件的通信过程是一样的。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/88.png" alt></p>
<h2 id="父级向子级传递"><a href="#父级向子级传递" class="headerlink" title="父级向子级传递"></a>父级向子级传递</h2><h3 id="props基本用法"><a href="#props基本用法" class="headerlink" title="props基本用法"></a>props基本用法</h3><p>在组件中，使用选项props来声明需要从父级接收到的数据。<br>props的值有两种方式：<br>方式一：字符串数组，数组中的字符串就是传递时的名称。<br>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。<br>我们先来看一个最简单的props传递：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/89.png" alt></p>
<h3 id="props数据验证"><a href="#props数据验证" class="headerlink" title="props数据验证"></a>props数据验证</h3><p>在前面，我们的props选项是使用一个数组。<br>我们说过，除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了。<br>验证都支持哪些数据类型呢？</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Function</li>
<li>Symbol</li>
</ul>
<p>当我们有自定义构造函数时，验证也支持自定义的类型<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/90.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/91.png" alt></p>
<h2 id="子级向父级传递"><a href="#子级向父级传递" class="headerlink" title="子级向父级传递"></a>子级向父级传递</h2><h3 id="子级向父级传递-1"><a href="#子级向父级传递-1" class="headerlink" title="子级向父级传递"></a>子级向父级传递</h3><p>props用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中。<br>我们应该如何处理呢？这个时候，我们需要使用自定义事件来完成。<br>什么时候需要自定义事件呢？<br>当子组件需要向父组件传递数据时，就要用到自定义事件了。<br>我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。<br>自定义事件的流程：<br>在子组件中，通过$emit()来触发事件。<br>在父组件中，通过v-on来监听子组件事件。<br>我们来看一个简单的例子：<br>我们之前做过一个两个按钮+1和-1，点击后修改counter。<br>我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件。<br>这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total。</p>
<h3 id="自定义事件代码"><a href="#自定义事件代码" class="headerlink" title="自定义事件代码"></a>自定义事件代码</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/92.png" alt></p>
<h2 id="父子组件的访问"><a href="#父子组件的访问" class="headerlink" title="父子组件的访问"></a>父子组件的访问</h2><h3 id="父子组件的访问方式：-children"><a href="#父子组件的访问方式：-children" class="headerlink" title="父子组件的访问方式： $children"></a>父子组件的访问方式： $children</h3><p>有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。<br>父组件访问子组件：使用$children或$refs<br>子组件访问父组件：使用$parent</p>
<p>我们先来看下$children的访问<br>this.$children是一个数组类型，它包含所有子组件对象。<br>我们这里通过一个遍历，取出所有子组件的message状态。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/93.png" alt></p>
<h3 id="父子组件的访问方式：-refs"><a href="#父子组件的访问方式：-refs" class="headerlink" title="父子组件的访问方式： $refs"></a>父子组件的访问方式： $refs</h3><p>$children的缺陷：<br>通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。<br>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。<br>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs<br>$refs的使用：<br>$refs和ref指令通常是一起使用的。<br>首先，我们通过ref给某一个子组件绑定一个特定的ID。<br>其次，通过this.$refs.ID就可以访问到该组件了。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/94.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/95.png" alt></p>
<h3 id="父子组件的访问方式：-parent"><a href="#父子组件的访问方式：-parent" class="headerlink" title="父子组件的访问方式： $parent"></a>父子组件的访问方式： $parent</h3><p>如果我们想在子组件中直接访问父组件，可以通过$parent<br>注意事项：<br>尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。<br>子组件应该尽量避免直接访问父组件的数据，因为这样耦合度太高了。<br>如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题。<br>另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/96.png" alt></p>
<h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><p>刚才我们讨论的都是父子组件间的通信，那如果是非父子关系呢?<br>非父子组件关系包括多个层级的组件，也包括兄弟组件的关系。<br>在Vue1.x的时候，可以通过$dispatch和$broadcast完成<br>$dispatch用于向上级派发事件<br>$broadcast用于向下级广播事件<br>但是在Vue2.x都被取消了<br>在Vue2.x中，有一种方案是通过中央事件总线，也就是一个中介来完成。<br>但是这种方案和直接使用Vuex的状态管理方案还是逊色很多。<br>并且Vuex提供了更多好用的功能，所以这里我们暂且不讨论这种方案，后续我们专门学习Vuex的状态管理。</p>
<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>在真正学习插槽之前，我们需要先理解一个概念：编译作用域。<br>官方对于编译的作用域解析比较简单，我们自己来通过一个例子来理解这个概念：<br>我们来考虑下面的代码是否最终是可以渲染出来的：<br><code>&lt;my-cpn v-show=&quot;isShow&quot;&gt;&lt;/my-cpn&gt;</code>中，我们使用了isShow属性。<br>isShow属性包含在组件中，也包含在Vue实例中。<br>答案：最终可以渲染出来，也就是使用的是Vue实例的属性。<br>为什么呢？<br>官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。<br>而我们在使用<code>&lt;my-cpn v-show=&quot;isShow&quot;&gt;&lt;/my-cpn&gt;</code>的时候，整个组件的使用过程是相当于在父组件中出现的。<br>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。<br>因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/97.png" alt></p>
<h3 id="为什么使用slot"><a href="#为什么使用slot" class="headerlink" title="为什么使用slot"></a>为什么使用slot</h3><p>slot翻译为插槽：<br>在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽。<br>插槽的目的是让我们原来的设备具备更多的扩展性。<br>比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等。<br>组件的插槽：<br>组件的插槽也是为了让我们封装的组件更加具有扩展性。<br>让使用者可以决定组件内部的一些内容到底展示什么。<br>栗子：移动网站中的导航栏。<br>移动开发中，几乎每个页面都有导航栏。<br>导航栏我们必然会封装成一个插件，比如nav-bar组件。<br>一旦有了这个组件，我们就可以在多个页面中复用了。<br>但是，每个页面的导航是一样的吗？No，我以京东M站为例<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/98.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/99.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/100.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/101.png" alt></p>
<h3 id="如何封装这类组件呢？slot"><a href="#如何封装这类组件呢？slot" class="headerlink" title="如何封装这类组件呢？slot"></a>如何封装这类组件呢？slot</h3><p>如何去封装这类的组件呢？<br>它们也很多区别，但是也有很多共性。<br>如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装。<br>但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等。<br>如何封装合适呢？抽取共性，保留不同。<br>最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。<br>一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。<br>是搜索框，还是文字，还是菜单。由调用者自己来决定。<br>这就是为什么我们要学习组件中的插槽slot的原因。</p>
<h3 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h3><p>了解了为什么用slot，我们再来谈谈如何使用slot？<br>在子组件中，使用特殊的元素<slot>就可以为子组件开启一个插槽。<br>该插槽插入什么内容取决于父组件如何使用。<br>我们通过一个简单的例子，来给子组件定义一个插槽：<br><slot>中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容<br>有了这个插槽后，父组件如何使用呢？<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/102.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/103.png" alt></slot></slot></p>
<h3 id="具名插槽slot"><a href="#具名插槽slot" class="headerlink" title="具名插槽slot"></a>具名插槽slot</h3><p>当子组件的功能复杂时，子组件的插槽可能并非是一个。<br>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。<br>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？<br>这个时候，我们就需要给插槽起一个名字<br>如何使用具名插槽呢？<br>非常简单，只要给slot元素一个name属性即可<br><code>&lt;slot name=&#39;myslot&#39;&gt;&lt;/slot&gt;</code><br>我们来给出一个案例：<br>这里我们先不对导航组件做非常复杂的封装，先了解具名插槽的用法。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/104.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/105.png" alt></p>
<h3 id="作用域插槽：准备"><a href="#作用域插槽：准备" class="headerlink" title="作用域插槽：准备"></a>作用域插槽：准备</h3><p>作用域插槽是slot一个比较难理解的点，而且官方文档说的又有点不清晰。<br>这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会：<br>父组件替换插槽的标签，但是内容由子组件来提供。<br>我们先提一个需求：<br>子组件中包括一组数据，比如：pLanguages: [‘JavaScript’, ‘Python’, ‘Swift’, ‘Go’, ‘C++’]<br>需要在多个界面进行展示：<br>某些界面是以水平方向一一展示的，<br>某些界面是以列表形式展示的，<br>某些界面直接展示一个数组<br>内容在子组件，希望父组件告诉我们如何展示，怎么办呢？<br>利用slot作用域插槽就可以了<br>我们来看看子组件的定义：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/106.png" alt></p>
<h3 id="作用域插槽：使用"><a href="#作用域插槽：使用" class="headerlink" title="作用域插槽：使用"></a>作用域插槽：使用</h3><p>在父组件使用我们的子组件时，从子组件中拿到数据：<br>我们通过<code>&lt;template slot-scope=&quot;slotProps&quot;&gt;</code>获取到slotProps属性<br>在通过slotProps.data就可以获取到刚才我们传入的data了<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/107.png" alt></p>
<h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><h3 id="JavaScript原始功能"><a href="#JavaScript原始功能" class="headerlink" title="JavaScript原始功能"></a>JavaScript原始功能</h3><p>在网页开发的早期，js制作作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的。<br>那个时候的代码是怎么写的呢？直接将代码写在<code>&lt;script&gt;</code>标签中即可<br>随着ajax异步请求的出现，慢慢形成了前后端的分离<br>客户端需要完成的事情越来越多，代码量也是与日俱增。<br>为了应对代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护。<br>但是这种维护方式，依然不能避免一些灾难性的问题。<br>比如全局变量同名问题：看右边的例子<br>另外，这种代码的编写方式对js文件的依赖顺序几乎是强制性的<br>但是当js文件过多，比如有几十个的时候，弄清楚它们的顺序是一件比较同时的事情。<br>而且即使你弄清楚顺序了，也不能避免上面出现的这种尴尬问题的发生。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/108.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/109.png" alt></p>
<h3 id="匿名函数的解决方案"><a href="#匿名函数的解决方案" class="headerlink" title="匿名函数的解决方案"></a>匿名函数的解决方案</h3><p>我们可以使用匿名函数来解决方面的重名问题<br>在aaa.js文件中，我们使用匿名函数<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/110.png" alt><br>但是如果我们希望在main.js文件中，用到flag，应该如何处理呢？<br>显然，另外一个文件中不容易使用，因为flag是一个局部变量。</p>
<h3 id="使用模块作为出口"><a href="#使用模块作为出口" class="headerlink" title="使用模块作为出口"></a>使用模块作为出口</h3><p>我们可以使用将需要暴露到外面的变量，使用一个模块作为出口，什么意思呢？<br>来看下对应的代码：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/111.png" alt><br>我们做了什么事情呢？<br>非常简单，在匿名函数内部，定义一个对象。<br>给对象添加各种需要暴露到外面的属性和方法(不需要暴露的直接定义即可)。<br>最后将这个对象返回，并且在外面使用了一个MoudleA接受。<br>接下来，我们在man.js中怎么使用呢？<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/112.png" alt><br>我们只需要使用属于自己模块的属性和方法即可<br>这就是模块最基础的封装，事实上模块的封装还有很多高级的话题：<br>但是我们这里就是要认识一下为什么需要模块，以及模块的原始雏形。<br>幸运的是，前端模块化开发已经有了很多既有的规范，以及对应的实现方案。<br>常见的模块化规范：<br>CommonJS、AMD、CMD，也有ES6的Modules</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="CommonJS-了解"><a href="#CommonJS-了解" class="headerlink" title="CommonJS(了解)"></a>CommonJS(了解)</h3><p>模块化有两个核心：导出和导入<br>CommonJS的导出：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/113.png" alt><br>CommonJS的导入<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/114.png" alt></p>
<h2 id="ES6的export指令"><a href="#ES6的export指令" class="headerlink" title="ES6的export指令"></a>ES6的export指令</h2><h3 id="export基本使用"><a href="#export基本使用" class="headerlink" title="export基本使用"></a>export基本使用</h3><p>export指令用于导出变量，比如下面的代码：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/115.png" alt><br>上面的代码还有另外一种写法：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/116.png" alt></p>
<h3 id="导出函数或类"><a href="#导出函数或类" class="headerlink" title="导出函数或类"></a>导出函数或类</h3><p>上面我们主要是输出变量，也可以输出函数或者输出类<br>上面的代码也可以写成这种形式<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/117.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/118.png" alt></p>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名<br>这个时候就可以使用export default<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/119.png" alt><br>我们来到main.js中，这样使用就可以了<br>这里的myFunc是我自己命名的，你可以根据需要命名它对应的名字<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/120.png" alt><br>另外，需要注意：<br>export default在同一个模块中，不允许同时存在多个。</p>
<h2 id="ES6的import指令"><a href="#ES6的import指令" class="headerlink" title="ES6的import指令"></a>ES6的import指令</h2><h3 id="import使用"><a href="#import使用" class="headerlink" title="import使用"></a>import使用</h3><p>我们使用export指令导出了模块对外提供的接口，下面我们就可以通过import命令来加载对应的这个模块了<br>首先，我们需要在HTML代码中引入两个js文件，并且类型需要设置为module<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/121.png" alt><br>import指令用于导入模块中的内容，比如main.js的代码<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/122.png" alt><br>如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦：<br>通过<code>*</code>可以导入模块中所有的export变量<br>但是通常情况下我们需要给*起一个别名，方便后续的使用<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/123.png" alt></p>
<h1 id="Webpack详解"><a href="#Webpack详解" class="headerlink" title="Webpack详解"></a>Webpack详解</h1><h2 id="认识webpack"><a href="#认识webpack" class="headerlink" title="认识webpack"></a>认识webpack</h2><h3 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h3><p>这个webpack还真不是一两句话可以说清楚的。<br>我们先看看官方的解释：<br>At its core, webpack is a static module bundler for modern JavaScript applications.<br>从本质上来讲，webpack是一个现代的JavaScript应用的静态模块打包工具。<br>但是它是什么呢？用概念解释概念，还是不清晰。<br>我们从两个点来解释上面这句话：模块 和 打包<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/124.png" alt></p>
<h3 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h3><ul>
<li>前端模块化：<br>在前面学习中，我已经用了大量的篇幅解释了为什么前端需要模块化。<br>而且我也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。<br>在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。<br>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。<br>而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。<br>而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用（在后续我们会看到）。<br>这就是webpack中模块化的概念</li>
<li>打包如何理解呢？<br>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。<br>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。<br>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。<br>但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？</li>
</ul>
<h3 id="和grunt-gulp的对比"><a href="#和grunt-gulp的对比" class="headerlink" title="和grunt/gulp的对比"></a>和grunt/gulp的对比</h3><ul>
<li>grunt/gulp的核心是Task<br>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）<br>之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。<br>所以grunt/gulp也被称为前端自动化任务管理工具。</li>
<li>我们来看一个gulp的task<br>下面的task就是将src下面的所有js文件转成ES5的语法。<br>并且最终输出到dist文件夹中。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/125.png" alt></li>
<li>什么时候用grunt/gulp呢？<br>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。<br>只需要进行简单的合并、压缩，就使用grunt/gulp即可。<br>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。</li>
<li>所以，grunt/gulp和webpack有什么不同呢？<br>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。<br>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><h3 id="webpack安装-1"><a href="#webpack安装-1" class="headerlink" title="webpack安装"></a>webpack安装</h3>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm<br>查看自己的node版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
全局安装webpack(这里我先指定版本号3.6.0，因为vue cli2依赖该版本)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node install webpack@3.6.0 -g</span><br></pre></td></tr></table></figure>
局部安装webpack（后续才需要）<br><code>--save-dev</code>是开发时依赖，项目打包后不需要继续使用的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 对应目录</span><br><span class="line">npm install webpack @3.6.0 --save-dev</span><br></pre></td></tr></table></figure>
为什么全局安装后，还需要局部安装呢？<br>在终端直接执行webpack命令，使用的全局安装的webpack<br>当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack<h2 id="webpack起步"><a href="#webpack起步" class="headerlink" title="webpack起步"></a>webpack起步</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3>我们创建如下文件和文件夹：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/126.png" alt><br>文件和文件夹解析：<br>dist文件夹：用于存放之后打包的文件<br>src文件夹：用于存放我们写的源文件<br>main.js：项目的入口文件。具体内容查看下面详情。<br>mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用。具体内容查看下面的详情。<br>index.html：浏览器打开展示的首页html<br>package.json：通过npm init生成的，npm包管理的文件（暂时没有用上，后面才会用上）<br>mathUtils.js文件中的代码：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/127.png" alt><br>main.js文件中的代码：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/128.png" alt><h3 id="js文件的打包"><a href="#js文件的打包" class="headerlink" title="js文件的打包"></a>js文件的打包</h3>现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。<br>因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码。<br>另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。<br>我们应该怎么做呢？使用webpack工具，对多个js文件进行打包。<br>我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。（如何处理的，待会儿在原理中，我会讲解）<br>另外，如果在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了。<br>OK，如何打包呢？使用webpack的指令即可<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/129.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/130.png" alt><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3>我们考虑一下，如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？<br>当然可以，就是创建一个webpack.config.js文件<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/131.png" alt><h3 id="局部安装webpack"><a href="#局部安装webpack" class="headerlink" title="局部安装webpack"></a>局部安装webpack</h3>目前，我们使用的webpack是全局的webpack，如果我们想使用局部来打包呢？<br>因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题。<br>所以通常一个项目，都有自己局部的webpack。<br>第一步，项目中需要安装自己局部的webpack<br>这里我们让局部安装webpack3.6.0<br>Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack@3.6.0 --save-dev</span><br></pre></td></tr></table></figure>
第二步，通过node_modules/.bin/webpack启动webpack打包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules&#x2F;.bin&#x2F;webpack</span><br></pre></td></tr></table></figure>
<img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/132.png" alt><h3 id="package-json中定义启动"><a href="#package-json中定义启动" class="headerlink" title="package.json中定义启动"></a>package.json中定义启动</h3>但是，每次执行都敲这么一长串有没有觉得不方便呢？<br>OK，我们可以在package.json的scripts中定义自己的执行脚本。<br>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/133.png" alt><br>首先，会寻找本地的node_modules/.bin路径中对应的命令。<br>如果没有找到，会去全局的环境变量中寻找。<br>如何执行我们的build指令呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<h2 id="css-loader的使用"><a href="#css-loader的使用" class="headerlink" title="css-loader的使用"></a>css-loader的使用</h2><h3 id="什么是loader？"><a href="#什么是loader？" class="headerlink" title="什么是loader？"></a>什么是loader？</h3>loader是webpack中一个非常核心的概念。<br>webpack用来做什么呢？<br>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。<br>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。<br>对于webpack本身的能力来说，对于这些转化是不支持的。<br>那怎么办呢？给webpack扩展对应的loader就可以啦。<br>loader使用过程：<br>步骤一：通过npm安装需要使用的loader<br>步骤二：在webpack.config.js中的modules关键字下进行配置<br>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法<h3 id="css文件处理-准备工作"><a href="#css文件处理-准备工作" class="headerlink" title="css文件处理 - 准备工作"></a>css文件处理 - 准备工作</h3>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。<br>在src目录中，创建一个css文件，其中创建一个normal.css文件。<br>我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/134.png" alt><br>normal.css中的代码非常简单，就是将body设置为red<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/135.png" alt><br>但是，这个时候normal.css中的样式会生效吗？<br>当然不会，因为我们压根就没有引用它。<br>webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件。</li>
</ul>
<p>在入口文件中引用：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/136.png" alt></p>
<h3 id="css文件处理-–-打包报错信息"><a href="#css文件处理-–-打包报错信息" class="headerlink" title="css文件处理 – 打包报错信息"></a>css文件处理 – 打包报错信息</h3><p>重新打包，会出现如下错误：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/137.png" alt><br>这个错误告诉我们：加载normal.css文件必须有对应的loader。</p>
<h3 id="css文件处理-–-css-loader"><a href="#css文件处理-–-css-loader" class="headerlink" title="css文件处理 – css-loader"></a>css文件处理 – css-loader</h3><p>在webpack的官方中，我们可以找到如下关于样式的loader使用方法：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/138.png" alt><br>按照官方配置webpack.config.js文件<br>注意：配置中有一个style-loader，我们并不知道它是什么，所以可以暂时不进行配置。</p>
<p>重新打包项目：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/139.png" alt><br>但是，运行index.html，你会发现样式并没有生效。<br>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。<br>这个时候，我们还需要一个style-loader帮助我们处理。</p>
<h3 id="css文件处理-–-style-loader"><a href="#css文件处理-–-style-loader" class="headerlink" title="css文件处理 – style-loader"></a>css文件处理 – style-loader</h3><p>我们来安装style-loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure>
<p>注意：style-loader需要放在css-loader的前面。<br>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？<br>答案：这次因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。<br>目前，webpack.config.js的配置如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/140.png" alt></p>
<h2 id="less文件处理"><a href="#less文件处理" class="headerlink" title="less文件处理"></a>less文件处理</h2><h3 id="less文件处理-–-准备工作"><a href="#less文件处理-–-准备工作" class="headerlink" title="less文件处理 – 准备工作"></a>less文件处理 – 准备工作</h3><p>如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？<br>我们这里以less为例，其他也是一样的。<br>我们还是先创建一个less文件，依然放在css文件夹中<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/141.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/142.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/143.png" alt></p>
<h3 id="less文件处理-–-less-loader"><a href="#less文件处理-–-less-loader" class="headerlink" title="less文件处理 – less-loader"></a>less文件处理 – less-loader</h3><p>继续在官方中查找，我们会找到less-loader相关的使用说明<br>首先，还是需要安装对应的loader<br>注意：我们这里还安装了less，因为webpack会使用less对less文件进行编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br></pre></td></tr></table></figure>
<p>其次，修改对应的配置文件<br>添加一个rules选项，用于处理.less文件<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/144.png" alt></p>
<h2 id="图片文件处理"><a href="#图片文件处理" class="headerlink" title="图片文件处理"></a>图片文件处理</h2><h3 id="图片文件处理-–-资源准备阶段"><a href="#图片文件处理-–-资源准备阶段" class="headerlink" title="图片文件处理 – 资源准备阶段"></a>图片文件处理 – 资源准备阶段</h3><p>首先，我们在项目中加入两张图片：<br>一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpeg(大于8kb)<br>待会儿我们会针对这两张图片进行不同的处理<br>我们先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/145.png" alt><br>如果我们现在直接打包，会出现如下问题<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/146.png" alt></p>
<h3 id="图片文件处理-–-url-loader"><a href="#图片文件处理-–-url-loader" class="headerlink" title="图片文件处理 – url-loader"></a>图片文件处理 – url-loader</h3><p>图片处理，我们使用url-loader来处理，依然先安装url-loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br></pre></td></tr></table></figure>
<p>修改webpack.config.js配置文件：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/147.png" alt><br>再次打包，运行index.html，就会发现我们的背景图片选出了出来。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/148.png" alt><br>而仔细观察，你会发现背景图是通过base64显示出来的<br>OK，这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码</p>
<h3 id="图片文件处理-–-file-loader"><a href="#图片文件处理-–-file-loader" class="headerlink" title="图片文件处理 – file-loader"></a>图片文件处理 – file-loader</h3><p>那么问题来了，如果大于8kb呢？我们将background的图片改成test02.jpg<br>这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/149.png" alt><br>所以，我们需要安装file-loader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure>
<p>再次打包，就会发现dist文件夹下多了一个图片文件<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/150.png" alt></p>
<h3 id="图片文件处理-–-修改文件名称"><a href="#图片文件处理-–-修改文件名称" class="headerlink" title="图片文件处理 – 修改文件名称"></a>图片文件处理 – 修改文件名称</h3><p>我们发现webpack自动帮助我们生成一个非常长的名字<br>这是一个32位hash值，目的是防止名字重复<br>但是，真实开发中，我们可能对打包的图片名字有一定的要求<br>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复<br>所以，我们可以在options中添加上如下选项：<br>img：文件要打包到的文件夹<br>name：获取图片原来的名字，放在该位置<br>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位<br>ext：使用图片原来的扩展名<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/151.png" alt><br>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确<br>默认情况下，webpack会将生成的路径直接返回给使用者<br>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/152.png" alt></p>
<h2 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h2><h3 id="ES6语法处理"><a href="#ES6语法处理" class="headerlink" title="ES6语法处理"></a>ES6语法处理</h3><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。<br>在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。<br>而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure>
<p>配置webpack.config.js文件<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/153.png" alt><br>重新打包，查看bundle.js文件，发现其中的内容变成了ES5的语法</p>
<h2 id="webpack配置vue"><a href="#webpack配置vue" class="headerlink" title="webpack配置vue"></a>webpack配置vue</h2><h3 id="引入vue-js"><a href="#引入vue-js" class="headerlink" title="引入vue.js"></a>引入vue.js</h3><p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。<br>所以，下面我们来学习一下如何在我们的webpack环境中集成Vuejs<br>现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装<br>注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>
<p>那么，接下来就可以按照我们之前学习的方式来使用Vue了<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/154.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/155.png" alt></p>
<h3 id="打包项目-–-错误信息"><a href="#打包项目-–-错误信息" class="headerlink" title="打包项目 – 错误信息"></a>打包项目 – 错误信息</h3><p>修改完成后，重新打包，运行程序：<br>打包过程没有任何错误(因为只是多打包了一个vue的js文件而已)<br>但是运行程序，没有出现想要的效果，而且浏览器中有报错<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/156.png" alt><br>这个错误说的是我们使用的是runtime-only版本的Vue，什么意思呢？<br>这里我只说解决方案：Vue不同版本构建，后续我具体讲解runtime-only和runtime-compiler的区别。<br>所以我们修改webpack的配置，添加如下内容即可<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/157.png" alt></p>
<h3 id="el和template区别（一）"><a href="#el和template区别（一）" class="headerlink" title="el和template区别（一）"></a>el和template区别（一）</h3><p>正常运行之后，我们来考虑另外一个问题：<br>如果我们希望将data中的数据显示在界面中，就必须是修改index.html<br>如果我们后面自定义了组件，也必须修改index.html来使用组件<br>但是html模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？<br>定义template属性：<br>在前面的Vue实例中，我们定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容<br>这里，我们可以将div元素中的内容删掉，只保留一个基本的id为div的元素<br>但是如果我依然希望在其中显示的内容，应该怎么处理呢？<br>我们可以再定义一个template属性，代码如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/158.png" alt></p>
<h3 id="el和template区别（二）"><a href="#el和template区别（二）" class="headerlink" title="el和template区别（二）"></a>el和template区别（二）</h3><p>重新打包，运行程序，显示一样的结果和HTML代码结构<br>那么，el和template模板的关系是什么呢？<br>在我们之前的学习中，我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等。<br>而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。<br>这样做有什么好处呢？<br>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可<br>但是，书写template模块非常麻烦怎么办呢？<br>没有关系，稍后我们会将template模板中的内容进行抽离。<br>会分成三部分书写：template、script、style，结构变得非常清晰。</p>
<h3 id="Vue组件化开发引入"><a href="#Vue组件化开发引入" class="headerlink" title="Vue组件化开发引入"></a>Vue组件化开发引入</h3><p>在学习组件化开发的时候，我说过以后的Vue开发过程中，我们都会采用组件化开发的思想。<br>那么，在当前项目中，如果我也想采用组件化的形式进行开发，应该怎么做呢？<br>查看下面的代码：<br>当然，我们也可以将下面的代码抽取到一个js文件中，并且导出。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/159.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/160.png" alt></p>
<h3 id="vue文件封装处理"><a href="#vue文件封装处理" class="headerlink" title=".vue文件封装处理"></a>.vue文件封装处理</h3><p>但是一个组件以一个js对象的形式进行组织和使用的时候是非常不方便的<br>一方面编写template模块非常的麻烦<br>另外一方面如果有样式的话，我们写在哪里比较合适呢？<br>现在，我们以一种全新的方式来组织一个vue的组件<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/161.png" alt><br>但是，这个时候这个文件可以被正确的加载吗？<br>必然不可以，这种特殊的文件以及特殊的格式，必须有人帮助我们处理。<br>谁来处理呢？vue-loader以及vue-template-compiler。<br>安装vue-loader和vue-template-compiler</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>
<p>修改webpack.config.js的配置文件：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/162.png" alt></p>
<h2 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h2><h3 id="认识plugin"><a href="#认识plugin" class="headerlink" title="认识plugin"></a>认识plugin</h3><p>plugin是什么？<br>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。<br>loader和plugin区别<br>loader主要用于转换某些类型的模块，它是一个转换器。<br>plugin是插件，它是对webpack本身的扩展，是一个扩展器。<br>plugin的使用过程：<br>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)<br>步骤二：在webpack.config.js中的plugins中配置插件。<br>下面，我们就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让我们的webpack变得更加好用。</p>
<h3 id="添加版权的Plugin"><a href="#添加版权的Plugin" class="headerlink" title="添加版权的Plugin"></a>添加版权的Plugin</h3><p>我们先来使用一个最简单的插件，为打包的文件添加版权声明<br>该插件名字叫BannerPlugin，属于webpack自带的插件。<br>按照下面的方式来修改webpack.config.js的文件：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/163.png" alt><br>重新打包程序：查看bundle.js文件的头部，看到如下信息<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/164.png" alt></p>
<h3 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h3><p>目前，我们的index.html文件是存放在项目的根目录下的。<br>我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。<br>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件<br>HtmlWebpackPlugin插件可以为我们做这些事情：<br>自动生成一个index.html文件(可以指定模板来生成)<br>将打包的js文件，自动通过script标签插入到body中<br>安装HtmlWebpackPlugin插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>
<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：<br>这里的template表示根据什么模板来生成index.html<br>另外，我们需要删除之前在output中添加的publicPath属性<br>否则插入的script标签中的src可能会有问题<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/165.png" alt></p>
<h3 id="js压缩的Plugin"><a href="#js压缩的Plugin" class="headerlink" title="js压缩的Plugin"></a>js压缩的Plugin</h3><p>在项目发布之前，我们必然需要对js等文件进行压缩处理<br>这里，我们就对打包的js文件进行压缩<br>我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure>
<p>修改webpack.config.js文件，使用插件：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/166.png" alt><br>查看打包后的bunlde.js文件，是已经被压缩过了。</p>
<h2 id="本地服务器"><a href="#本地服务器" class="headerlink" title="本地服务器"></a>本地服务器</h2><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><p>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。<br>不过它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@2.9.1</span><br></pre></td></tr></table></figure>
<p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：<br>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist<br>port：端口号<br>inline：页面实时刷新<br>historyApiFallback：在SPA页面中，依赖HTML5的history模式<br>webpack.config.js文件配置修改如下：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/167.png" alt><br>我们可以再配置另外一个scripts：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/168.png" alt><br>–open参数表示直接打开浏览器</p>
<h1 id="Vue-CLI相关"><a href="#Vue-CLI相关" class="headerlink" title="Vue CLI相关"></a>Vue CLI相关</h1><h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><h3 id="什么是Vue-CLI"><a href="#什么是Vue-CLI" class="headerlink" title="什么是Vue CLI"></a>什么是Vue CLI</h3><p>如果你只是简单写几个Vue的Demo程序, 那么你不需要Vue CLI.<br>如果你在开发大型项目, 那么你需要, 并且必然需要使用Vue CLI<br>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。<br>如果每个项目都要手动完成这些工作，那无以效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。<br>CLI是什么意思?<br>CLI是Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架.<br>Vue CLI是一个官方发布 vue.js 项目脚手架<br>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置.<br>脚手架长什么样子?<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/169.png" alt></p>
<h3 id="Vue-CLI使用前提-Node"><a href="#Vue-CLI使用前提-Node" class="headerlink" title="Vue CLI使用前提 - Node"></a>Vue CLI使用前提 - Node</h3><p><strong>安装NodeJS</strong><br>可以直接在官方网站中下载安装.<br>网址: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br><strong>检测安装的版本</strong><br>默认情况下自动安装Node和NPM<br>Node环境要求8.9以上或者更高版本<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/170.png" alt><br><strong>什么是NPM呢?</strong><br>NPM的全称是Node Package Manager<br>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。<br>后续我们会经常使用NPM来安装一些开发过程中依赖包.<br>cnpm安装<br>由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。<br>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 cnpm 命令来安装模块了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install [name]</span><br></pre></td></tr></table></figure>
<h3 id="Vue-CLI使用前提-Webpack"><a href="#Vue-CLI使用前提-Webpack" class="headerlink" title="Vue CLI使用前提 - Webpack"></a>Vue CLI使用前提 - Webpack</h3><p>Vue.js官方脚手架工具就使用了webpack模板<br>对所有的资源会压缩等优化操作<br>它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效。<br>Webpack的全局安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure>
<h3 id="Vue-CLI的使用"><a href="#Vue-CLI的使用" class="headerlink" title="Vue CLI的使用"></a>Vue CLI的使用</h3><p>安装Vue脚手架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
<p>注意：上面安装的是Vue CLI3的版本，如果需要想按照Vue CLI2的方式初始化项目时不可以的。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/171.png" alt><br>Vue CLI2初始化项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>
<p>Vue CLI3初始化项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-project</span><br></pre></td></tr></table></figure>
<h2 id="Vue-CLI2"><a href="#Vue-CLI2" class="headerlink" title="Vue CLI2"></a>Vue CLI2</h2><h3 id="Vue-CLI2详解"><a href="#Vue-CLI2详解" class="headerlink" title="Vue CLI2详解"></a>Vue CLI2详解</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/172.png" alt></p>
<h3 id="目录结构详解"><a href="#目录结构详解" class="headerlink" title="目录结构详解"></a>目录结构详解</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/173.png" alt></p>
<h3 id="Runtime-Compiler和Runtime-only的区别"><a href="#Runtime-Compiler和Runtime-only的区别" class="headerlink" title="Runtime-Compiler和Runtime-only的区别"></a>Runtime-Compiler和Runtime-only的区别</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/174.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/175.png" alt><br>简单总结<br>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler<br>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only</p>
<h3 id="render和template"><a href="#render和template" class="headerlink" title="render和template"></a>render和template</h3><p>Runtime-Compiler 和 Runtime-only<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/176.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/177.png" alt><br>为什么存在这样的差异呢？<br>我们需要先理解Vue应用程序是如何运行起来的。<br>Vue中的模板如何最终渲染成真实DOM。<br>我们来看下面的一幅图。</p>
<h3 id="Vue程序运行过程"><a href="#Vue程序运行过程" class="headerlink" title="Vue程序运行过程"></a>Vue程序运行过程</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/178.png" alt></p>
<h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/179.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/180.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/181.png" alt></p>
<h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a>npm run build</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/182.png" alt></p>
<h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/183.png" alt></p>
<h3 id="修改配置：webpack-base-conf-js起别名"><a href="#修改配置：webpack-base-conf-js起别名" class="headerlink" title="修改配置：webpack.base.conf.js起别名"></a>修改配置：webpack.base.conf.js起别名</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/184.png" alt></p>
<h2 id="Vue-CLI3"><a href="#Vue-CLI3" class="headerlink" title="Vue CLI3"></a>Vue CLI3</h2><h3 id="认识Vue-CLI3"><a href="#认识Vue-CLI3" class="headerlink" title="认识Vue CLI3"></a>认识Vue CLI3</h3><p>2019年8月份刚刚发布<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/185.png" alt><br>vue-cli 3 与 2 版本有很大区别<br>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3<br>vue-cli 3 的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录<br>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化<br>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</p>
<h3 id="Vue-CLI3-1"><a href="#Vue-CLI3-1" class="headerlink" title="Vue CLI3"></a>Vue CLI3</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/186.png" alt></p>
<h3 id="目录结构详解-1"><a href="#目录结构详解-1" class="headerlink" title="目录结构详解"></a>目录结构详解</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/187.png" alt></p>
<h3 id="配置去哪里了？"><a href="#配置去哪里了？" class="headerlink" title="配置去哪里了？"></a>配置去哪里了？</h3><p>UI方面的配置<br>启动配置服务器：vue ui<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/188.png" alt><br>一大堆配置文件去哪里了？<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/189.png" alt></p>
<h3 id="自定义配置：起别名"><a href="#自定义配置：起别名" class="headerlink" title="自定义配置：起别名"></a>自定义配置：起别名</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/190.png" alt></p>
<h1 id="vue-router详解"><a href="#vue-router详解" class="headerlink" title="vue-router详解"></a>vue-router详解</h1><h2 id="认识路由"><a href="#认识路由" class="headerlink" title="认识路由"></a>认识路由</h2><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>说起路由你想起了什么？<br>路由是一个网络工程里面的术语。<br>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动. — 维基百科<br>额, 啥玩意? 没听懂<br>在生活中, 我们有没有听说过路由的概念呢? 当然了, 路由器嘛.<br>路由器是做什么的? 你有想过吗?<br>路由器提供了两种机制: 路由和转送.<br>路由是决定数据包从来源到目的地的路径.<br>转送将输入端的数据转移到合适的输出端.<br>路由中有一个非常重要的概念叫路由表.<br>路由表本质上就是一个映射表, 决定了数据包的指向.</p>
<h3 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h3><p>早期的网站开发整个HTML页面是由服务器来渲染的.<br>服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.<br>但是, 一个网站, 这么多页面服务器如何处理呢?<br>一个页面有自己对应的网址, 也就是URL.<br>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理.<br>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.<br>这就完成了一个IO操作.<br>上面的这种操作, 就是后端路由.<br>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿.<br>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.<br>后端路由的缺点:<br>一种情况是整个页面的模块由后端人员来编写和维护的.<br>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.<br>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.</p>
<h3 id="前端路由阶段"><a href="#前端路由阶段" class="headerlink" title="前端路由阶段"></a>前端路由阶段</h3><p>前后端分离阶段：<br>随着Ajax的出现, 有了前后端分离的开发模式.<br>后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中.<br>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.<br>并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.<br>目前很多的网站依然采用这种模式开发.<br>单页面富应用阶段:<br>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由.<br>也就是前端来维护一套路由规则.<br>前端路由的核心是什么呢？<br>改变URL，但是页面不进行整体的刷新。<br>如何实现呢？</p>
<h2 id="前端路由的规则"><a href="#前端路由的规则" class="headerlink" title="前端路由的规则"></a>前端路由的规则</h2><h3 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h3><p>URL的hash<br>URL的hash也就是锚点(#), 本质上是改变window.location的href属性.<br>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/191.png" alt></p>
<h3 id="HTML5的history模式：pushState"><a href="#HTML5的history模式：pushState" class="headerlink" title="HTML5的history模式：pushState"></a>HTML5的history模式：pushState</h3><p>history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.<br>history.pushState()<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/192.png" alt></p>
<h3 id="HTML5的history模式：replaceState"><a href="#HTML5的history模式：replaceState" class="headerlink" title="HTML5的history模式：replaceState"></a>HTML5的history模式：replaceState</h3><p>history.replaceState()<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/193.png" alt></p>
<h3 id="HTML5的history模式：go"><a href="#HTML5的history模式：go" class="headerlink" title="HTML5的history模式：go"></a>HTML5的history模式：go</h3><p>history.go()<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/194.png" alt><br><strong>补充说明：</strong><br>上面只演示了三个方法<br>因为 history.back() 等价于 history.go(-1)<br>history.forward() 则等价于 history.go(1)<br>这三个接口等同于浏览器界面的前进后退。</p>
<h2 id="vue-router基础"><a href="#vue-router基础" class="headerlink" title="vue-router基础"></a>vue-router基础</h2><h3 id="认识vue-router"><a href="#认识vue-router" class="headerlink" title="认识vue-router"></a>认识vue-router</h3><p>目前前端流行的三大框架, 都有自己的路由实现:<br>Angular的ngRouter<br>React的ReactRouter<br>Vue的vue-router<br>当然, 我们的重点是vue-router<br>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。<br>我们可以访问其官方网站对其进行学习: <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a><br>vue-router是基于路由和组件的<br>路由用于设定访问路径, 将路径和组件映射起来.<br>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</p>
<h3 id="安装和使用vue-router"><a href="#安装和使用vue-router" class="headerlink" title="安装和使用vue-router"></a>安装和使用vue-router</h3><p>因为我们已经学习了webpack, 后续开发中我们主要是通过工程化的方式进行开发的.<br>所以在后续, 我们直接使用npm来安装路由即可.<br>步骤一: 安装vue-router<br>npm install vue-router –save<br>步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能)<br>第一步：导入路由对象，并且调用 Vue.use(VueRouter)<br>第二步：创建路由实例，并且传入路由映射配置<br>第三步：在Vue实例中挂载创建的路由实例<br>使用vue-router的步骤:<br>第一步: 创建路由组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39; </span><br><span class="line">import VueRouter from &#39;vue-router&#39; </span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
<h3 id="创建router实例"><a href="#创建router实例" class="headerlink" title="创建router实例"></a>创建router实例</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/195.png" alt></p>
<h3 id="挂载到Vue实例中"><a href="#挂载到Vue实例中" class="headerlink" title="挂载到Vue实例中"></a>挂载到Vue实例中</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/196.png" alt></p>
<h3 id="步骤一：创建路由组件"><a href="#步骤一：创建路由组件" class="headerlink" title="步骤一：创建路由组件"></a>步骤一：创建路由组件</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/197.png" alt></p>
<h3 id="步骤二：配置组件和路径的映射关系"><a href="#步骤二：配置组件和路径的映射关系" class="headerlink" title="步骤二：配置组件和路径的映射关系"></a>步骤二：配置组件和路径的映射关系</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/198.png" alt></p>
<h3 id="步骤三：使用路由"><a href="#步骤三：使用路由" class="headerlink" title="步骤三：使用路由"></a>步骤三：使用路由</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/199.png" alt><br><code>&lt;router-link&gt;</code>: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个<code>&lt;a&gt;</code>标签.<br><code>&lt;router-view&gt;</code>: 该标签会根据当前的路径, 动态渲染出不同的组件.<br>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<code>&lt;router-view&gt;</code>处于同一个等级.<br>在路由切换时, 切换的是<code>&lt;router-view&gt;</code>挂载的组件, 其他内容不会发生改变.</p>
<h3 id="最终效果如下"><a href="#最终效果如下" class="headerlink" title="最终效果如下"></a>最终效果如下</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/200.png" alt></p>
<h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><p>我们这里还有一个不太好的实现:<br>默认情况下, 进入网站的首页, 我们希望<router-view>渲染首页的内容.<br>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以.<br>如何可以让路径默认跳到到首页, 并且<router-view>渲染首页组件呢?<br>非常简单, 我们只需要配置多配置一个映射就可以了.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/201.png" alt><br>配置解析:<br>我们在routes中又配置了一个映射.<br>path配置的是根路径: /<br>redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了</router-view></router-view></p>
<h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><p>我们前面说过改变路径的方式有两种:<br>URL的hash<br>HTML5的history<br>默认情况下, 路径的改变使用的URL的hash.<br>如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/202.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/203.png" alt></p>
<h3 id="router-link补充"><a href="#router-link补充" class="headerlink" title="router-link补充"></a>router-link补充</h3><p>在前面的<code>&lt;router-link&gt;</code>中, 我们只是使用了一个属性: to, 用于指定跳转的路径.<br><code>&lt;router-link&gt;</code>还有一些其他属性:<br>tag: tag可以指定<code>&lt;router-link&gt;</code>之后渲染成什么组件, 比如上面的代码会被渲染成一个<code>&lt;li&gt;</code>元素, 而不是<code>&lt;a&gt;</code><br>replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中<br>active-class: 当<code>&lt;router-link&gt;</code>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称.<br>在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类.<br>但是通常不会修改类的属性, 会直接使用默认的router-link-active即可.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/204.png" alt></p>
<h3 id="修改linkActiveClass"><a href="#修改linkActiveClass" class="headerlink" title="修改linkActiveClass"></a>修改linkActiveClass</h3><p>该class具体的名称也可以通过router实例的属性进行修改<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/205.png" alt><br>exact-active-class<br>类似于active-class, 只是在精准匹配下才会出现的class.<br>后面看到嵌套路由时, 我们再看下这个属性.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/206.png" alt></p>
<h3 id="路由代码跳转"><a href="#路由代码跳转" class="headerlink" title="路由代码跳转"></a>路由代码跳转</h3><p>有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了<br>比如, 我们将代码修改如下:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/207.png" alt></p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：<br>/user/aaaa或/user/bbbb<br>除了有前面的/user之外，后面还跟上了用户的ID<br>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/208.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/209.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/210.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/211.png" alt></p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><h3 id="认识路由的懒加载"><a href="#认识路由的懒加载" class="headerlink" title="认识路由的懒加载"></a>认识路由的懒加载</h3><p>官方给出了解释:<br>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。<br>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了<br>官方在说什么呢?<br>首先, 我们知道路由中通常会定义很多不同的页面.<br>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中.<br>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大.<br>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.<br>如何避免这种情况呢? 使用路由懒加载就可以了.<br>路由懒加载做了什么?<br>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.<br>只有在这个路由被访问到的时候, 才加载对应的组件</p>
<h3 id="路由懒加载的效果"><a href="#路由懒加载的效果" class="headerlink" title="路由懒加载的效果"></a>路由懒加载的效果</h3><p>直接使用：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/212.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/213.png" alt><br>使用懒加载：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/214.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/215.png" alt></p>
<h3 id="懒加载的方式"><a href="#懒加载的方式" class="headerlink" title="懒加载的方式"></a>懒加载的方式</h3><p>方式一: 结合Vue的异步组件和Webpack的代码分析.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Home &#x3D; resolve &#x3D;&gt; &#123; require.ensure([&#39;..&#x2F;components&#x2F;Home.vue&#39;],</span><br><span class="line"> () &#x3D;&gt; &#123; resolve(require(&#39;..&#x2F;components&#x2F;Home.vue&#39;)) &#125;)&#125;;</span><br></pre></td></tr></table></figure>
<p>方式二: AMD写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const About &#x3D; resolve &#x3D;&gt; require([&#39;..&#x2F;components&#x2F;About.vue&#39;], resolve);</span><br></pre></td></tr></table></figure>
<p>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Home &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;Home.vue&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><h3 id="认识嵌套路由"><a href="#认识嵌套路由" class="headerlink" title="认识嵌套路由"></a>认识嵌套路由</h3><p>嵌套路由是一个很常见的功能<br>比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容.<br>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.<br>路径和组件的关系如下:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/216.png" alt><br>实现嵌套路由有两个步骤:<br>创建对应的子组件, 并且在路由映射中配置对应的子路由.<br>在组件内部使用<code>&lt;router-view&gt;</code>标签.</p>
<h3 id="嵌套路由实现"><a href="#嵌套路由实现" class="headerlink" title="嵌套路由实现"></a>嵌套路由实现</h3><p>定义两个组件:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/217.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/218.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/219.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/220.png" alt></p>
<h3 id="嵌套默认路径"><a href="#嵌套默认路径" class="headerlink" title="嵌套默认路径"></a>嵌套默认路径</h3><p>嵌套路由也可以配置默认的路径, 配置方式如下:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/221.png" alt></p>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><h3 id="为什么使用导航守卫"><a href="#为什么使用导航守卫" class="headerlink" title="为什么使用导航守卫?"></a>为什么使用导航守卫?</h3><p>我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢?<br>网页标题是通过<code>&lt;title&gt;</code>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变.<br>但是我们可以通过JavaScript来修改<code>&lt;title&gt;</code>的内容.window.document.title = ‘新的标题’.<br>那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?<br>普通的修改方式:<br>我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中.<br>通过mounted声明周期函数, 执行对应的代码进行修改即可.<br>但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码).<br>有没有更好的办法呢? 使用导航守卫即可.<br>什么是导航守卫?<br>vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.<br>vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.</p>
<h3 id="导航守卫使用"><a href="#导航守卫使用" class="headerlink" title="导航守卫使用"></a>导航守卫使用</h3><p>我们可以利用beforeEach来完成标题的修改.<br>首先, 我们可以在钩子当中定义一些标题, 可以利用meta来定义<br>其次, 利用导航守卫,修改我们的标题.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/222.png" alt><br>导航钩子的三个参数解析:<br>to: 即将要进入的目标的路由对象.<br>from: 当前导航即将要离开的路由对象.<br>next: 调用该方法后, 才能进入下一个钩子.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/223.png" alt></p>
<h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><p>补充一:如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.<br>补充二: 上面我们使用的导航守卫, 被称之为全局守卫.<br>路由独享的守卫.<br>组件内的守卫.</p>
<p>更多内容, 可以查看官网进行学习:<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB</a></p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><h3 id="keep-alive遇见vue-router"><a href="#keep-alive遇见vue-router" class="headerlink" title="keep-alive遇见vue-router"></a>keep-alive遇见vue-router</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>它们有两个非常重要的属性:<br>include - 字符串或正则表达，只有匹配的组件会被缓存<br>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存<br>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/224.png" alt></p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了演示传递参数, 我们这里再创建一个组件, 并且将其配置好<br>第一步: 创建新的组件Profile.vue<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/225.png" alt><br>第二步: 配置路由映射<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/226.png" alt><br>第三步: 添加跳转的<code>&lt;router-link&gt;</code><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/227.png" alt></p>
<h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><p>传递参数主要有两种类型: params和query<br><strong>params的类型:</strong><br>配置路由格式: /router/:id<br>传递的方式: 在path后面跟上对应的值<br>传递后形成的路径: /router/123, /router/abc<br><strong>query的类型:</strong><br>配置路由格式: /router, 也就是普通配置<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</p>
<h3 id="传递参数方式一"><a href="#传递参数方式一" class="headerlink" title="传递参数方式一: "></a>传递参数方式一: <router-link></router-link></h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/228.png" alt></p>
<h3 id="传递参数方式二-JavaScript代码"><a href="#传递参数方式二-JavaScript代码" class="headerlink" title="传递参数方式二: JavaScript代码"></a>传递参数方式二: JavaScript代码</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/229.png" alt></p>
<h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>获取参数通过$route对象获取的.<br>在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新。<br>通过$route获取传递的信息如下:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/230.png" alt></p>
<h3 id="route和-router是有区别的"><a href="#route和-router是有区别的" class="headerlink" title="$route和$router是有区别的"></a>$route和$router是有区别的</h3><p>$route和$router是有区别的<br>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法<br>$route为当前router跳转对象里面可以获取name、path、query、params等<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/231.png" alt></p>
<h2 id="tabbar练习"><a href="#tabbar练习" class="headerlink" title="tabbar练习"></a>tabbar练习</h2><h3 id="TabBar实现思路"><a href="#TabBar实现思路" class="headerlink" title="TabBar实现思路"></a>TabBar实现思路</h3><p>1.如果在下方有一个单独的TabBar组件，你如何封装<br>自定义TabBar组件，在APP中使用<br>让TabBar出于底部，并且设置相关的样式<br>2.TabBar中显示的内容由外界决定<br>定义插槽<br>flex布局平分TabBar<br>3.自定义TabBarItem，可以传入 图片和文字<br>定义TabBarItem，并且定义两个插槽：图片、文字。<br>给两个插槽外层包装div，用于设置样式。<br>填充插槽，实现底部TabBar的效果<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/232.png" alt></p>
<h3 id="TabBar实现思路-1"><a href="#TabBar实现思路-1" class="headerlink" title="TabBar实现思路"></a>TabBar实现思路</h3><p>4.传入 高亮图片<br>定义另外一个插槽，插入active-icon的数据<br>定义一个变量isActive，通过v-show来决定是否显示对应的icon<br>5.TabBarItem绑定路由数据<br>安装路由：npm install vue-router —save<br>完成router/index.js的内容，以及创建对应的组件<br>main.js中注册router<br>APP中加入<router-view>组件<br>6.点击item跳转到对应路由，并且动态决定isActive<br>监听item的点击，通过this.$router.replace()替换路由路径<br>通过this.$route.path.indexOf(this.link) !== -1来判断是否是active<br>7.动态计算active样式<br>封装新的计算属性：this.isActive ? {‘color’: ‘red’} : {}</router-view></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/233.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/234.png" alt></p>
<h1 id="Vuex详解"><a href="#Vuex详解" class="headerlink" title="Vuex详解"></a>Vuex详解</h1><h2 id="认识Vuex"><a href="#认识Vuex" class="headerlink" title="认识Vuex"></a>认识Vuex</h2><h3 id="Vuex是做什么的"><a href="#Vuex是做什么的" class="headerlink" title="Vuex是做什么的?"></a>Vuex是做什么的?</h3><p>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。<br>它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。<br><strong>状态管理</strong>到底是什么？<br><strong>状态管理模式</strong>、<strong>集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。<br>其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。<br>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。<br>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？<br>等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？<br>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是响应式。<br>如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。<br>不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。</p>
<h3 id="管理什么状态呢"><a href="#管理什么状态呢" class="headerlink" title="管理什么状态呢?"></a>管理什么状态呢?</h3><p>但是，有什么状态时需要我们在多个组件间共享的呢？<br>如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。<br>比如用户的登录状态、用户名称、头像、地理位置信息等等。<br>比如商品的收藏、购物车中的物品等等。<br>这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的（待会儿我们就可以看到代码了，莫着急）。</p>
<p>OK，从理论上理解了状态管理之后，让我们从实际的代码再来看看状态管理。<br>毕竟，Talk is cheap, Show me the code.(来自Linus)</p>
<p>我们先来看看但界面的状态管理吧.</p>
<h3 id="单界面的状态管理"><a href="#单界面的状态管理" class="headerlink" title="单界面的状态管理"></a>单界面的状态管理</h3><p>我们知道，要在单个组件中进行状态管理是一件非常简单的事情<br>什么意思呢？我们来看下面的图片。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/235.png" alt><br>这图片中的三种东西，怎么理解呢？<br>State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）<br>View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）<br>Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</p>
<p>写点代码，加深理解：<br>看下右边的代码效果, 肯定会实现吧?<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/236.png" alt></p>
<h3 id="单界面状态管理的实现"><a href="#单界面状态管理的实现" class="headerlink" title="单界面状态管理的实现"></a>单界面状态管理的实现</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/237.png" alt><br>在这个案例中，我们有木有状态需要管理呢？没错，就是个数counter。<br>counter需要某种方式被记录下来，也就是我们的State。<br>counter目前的值需要被显示在界面中，也就是我们的View部分。<br>界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions<br>这不就是上面的流程图了吗？</p>
<h3 id="多界面状态管理"><a href="#多界面状态管理" class="headerlink" title="多界面状态管理"></a>多界面状态管理</h3><p>Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？<br>多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）<br>不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）<br>也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的<br>状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。<br>但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！<br>没错，Vuex就是为我们提供这个大管家的工具。<br>全局单例模式（大管家）<br>我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。<br>之后，你们每个试图，按照我规定好的规定，进行访问和修改等操作。<br>这就是Vuex背后的基本思想。</p>
<h3 id="Vuex状态管理图例"><a href="#Vuex状态管理图例" class="headerlink" title="Vuex状态管理图例"></a>Vuex状态管理图例</h3><p>一起在来看一副官方给出的图片<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/238.png" alt></p>
<h2 id="Vuex基本使用"><a href="#Vuex基本使用" class="headerlink" title="Vuex基本使用"></a>Vuex基本使用</h2><h3 id="简单的案例"><a href="#简单的案例" class="headerlink" title="简单的案例"></a>简单的案例</h3><p>我们还是实现一下之前简单的案例<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/239.png" alt><br>首先，我们需要在某个地方存放我们的Vuex代码：<br>这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件<br>在index.js文件中写入如下代码：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/240.png" alt></p>
<h3 id="挂载到Vue实例中-1"><a href="#挂载到Vue实例中-1" class="headerlink" title="挂载到Vue实例中"></a>挂载到Vue实例中</h3><p>其次，我们让所有的Vue组件都可以使用这个store对象<br>来到main.js文件，导入store对象，并且放在new Vue中<br>这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/241.png" alt></p>
<h3 id="使用Vuex的count"><a href="#使用Vuex的count" class="headerlink" title="使用Vuex的count"></a>使用Vuex的count</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/242.png" alt><br>好的，这就是使用Vuex最简单的方式了。<br>我们来对使用步骤，做一个简单的小节：<br>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态<br>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到<br>3.在其他组件中使用store对象中保存的状态即可<br>通过this.$store.state.属性的方式来访问状态<br>通过this.$store.commit(‘mutation中方法’)来修改状态<br>注意事项：<br>我们通过提交mutation的方式，而非直接改变store.state.count。<br>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</p>
<h2 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h2><h3 id="Vuex核心概念-1"><a href="#Vuex核心概念-1" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h3><p>Vuex有几个比较核心的概念:<br>State<br>Getters<br>Mutation<br>Action<br>Module<br>我们对它进行一一介绍.</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="State单一状态树"><a href="#State单一状态树" class="headerlink" title="State单一状态树"></a>State单一状态树</h3><p>Vuex提出使用单一状态树, 什么是单一状态树呢？<br>英文名称是Single Source of Truth，也可以翻译成单一数据源。<br>但是，它是什么呢？我们来看一个生活中的例子。<br>OK，我用一个生活中的例子做一个简单的类比。<br>我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。<br>这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。<br>这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。<br>这个和我们在应用开发中比较类似：<br>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。<br>所以Vuex也使用了单一状态树来管理应用层级的全部状态。<br>单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</p>
<h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><h3 id="Getters基本使用"><a href="#Getters基本使用" class="headerlink" title="Getters基本使用"></a>Getters基本使用</h3><p>有时候，我们需要从store中获取一些state变异后的状态，比如下面的Store中：<br>获取学生年龄大于20的个数。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/243.png" alt><br>我们可以在Store中定义getters<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/244.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/245.png" alt></p>
<h3 id="Getters作为参数和传递参数"><a href="#Getters作为参数和传递参数" class="headerlink" title="Getters作为参数和传递参数"></a>Getters作为参数和传递参数</h3><p>如果我们已经有了一个获取所有年龄大于20岁学生列表的getters, 那么代码可以这样来写<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/246.png" alt><br>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.<br>比如上面的案例中,我们希望根据ID获取用户的信息<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/247.png" alt></p>
<h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><h3 id="Mutation状态更新"><a href="#Mutation状态更新" class="headerlink" title="Mutation状态更新"></a>Mutation状态更新</h3><p>Vuex的store状态的更新唯一方式：提交Mutation<br>Mutation主要包括两部分：<br>字符串的事件类型（type）<br>一个回调函数（handler）,该回调函数的第一个参数就是state。<br>mutation的定义方式：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/248.png" alt><br>通过mutation更新<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/249.png" alt></p>
<h3 id="Mutation传递参数"><a href="#Mutation传递参数" class="headerlink" title="Mutation传递参数"></a>Mutation传递参数</h3><p>在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数<br>参数被称为是mutation的载荷(Payload)<br>Mutation中的代码:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/250.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/251.png" alt><br>但是如果参数不是一个呢?<br>比如我们有很多参数需要传递.<br>这个时候, 我们通常会以对象的形式传递, 也就是payload是一个对象.<br>这个时候可以再从对象中取出相关的信息.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/252.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/253.png" alt></p>
<h3 id="Mutation提交风格"><a href="#Mutation提交风格" class="headerlink" title="Mutation提交风格"></a>Mutation提交风格</h3><p>上面的通过commit进行提交是一种普通的方式<br>Vue还提供了另外一种风格, 它是一个包含type属性的对象<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/254.png" alt><br>Mutation中的处理方式是将整个commit的对象作为payload使用, 所以代码没有改变, 依然如下:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/255.png" alt></p>
<h3 id="Mutation响应规则"><a href="#Mutation响应规则" class="headerlink" title="Mutation响应规则"></a>Mutation响应规则</h3><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.<br>这就要求我们必须遵守一些Vuex对应的规则:<br>提前在store中初始化好所需的属性.<br>当给state中的对象添加新属性时, 使用下面的方式:<br>方式一: 使用Vue.set(obj, ‘newProp’, 123)<br>方式二: 用心对象给旧对象重新赋值<br>我们来看一个例子:<br>当我们点击更新信息时, 界面并没有发生对应改变.<br>如何才能让它改变呢?<br>查看下面代码的方式一和方式二<br>都可以让state中的属性是响应式的.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/256.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/257.png" alt></p>
<h3 id="Mutation常量类型-–-概念"><a href="#Mutation常量类型-–-概念" class="headerlink" title="Mutation常量类型 – 概念"></a>Mutation常量类型 – 概念</h3><p>我们来考虑下面的问题:<br>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).<br>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.<br>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.<br>如何避免上述的问题呢?<br>在各种Flux实现中, 一种很常见的方案就是使用常量替代Mutation事件的类型.<br>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.<br>具体怎么做呢?<br>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.<br>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</p>
<h3 id="Mutation常量类型-–-代码"><a href="#Mutation常量类型-–-代码" class="headerlink" title="Mutation常量类型 – 代码"></a>Mutation常量类型 – 代码</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/258.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/259.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/260.png" alt></p>
<h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><p>通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.<br>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.<br>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.<br>比如我们之前的代码, 当执行更新时, devtools中会有如下信息: 图1<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/261.png" alt><br>但是, 如果Vuex中的代码, 我们使用了异步函数: 图2<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/262.png" alt><br>你会发现state中的info数据一直没有被改变, 因为他无法追踪到.<br>So, 通常情况下, 不要再mutation中进行异步的操作</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><p>我们强调, 不要再Mutation中进行异步操作.<br>但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候怎么处理呢?<br>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.<br>Action的基本使用代码如下:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/263.png" alt><br>context是什么?<br>context是和store对象具有相同方法和属性的对象.<br>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.<br>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候, 再具体说.<br>这样的代码是否多此一举呢?<br>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?<br>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了</p>
<h3 id="Action的分发"><a href="#Action的分发" class="headerlink" title="Action的分发"></a>Action的分发</h3><p>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/264.png" alt><br>同样的, 也是支持传递payload<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/265.png" alt></p>
<h3 id="Action返回的Promise"><a href="#Action返回的Promise" class="headerlink" title="Action返回的Promise"></a>Action返回的Promise</h3><p>前面我们学习ES6语法的时候说过, Promise经常用于异步操作.<br>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject.<br>OK, 我们来看下面的代码:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/266.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/267.png" alt></p>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<br>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.<br>当应用变得非常复杂时,store对象就有可能变得相当臃肿.<br>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</p>
<p>我们按照什么样的方式来组织模块呢?<br>我们来看下面的代码<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/268.png" alt></p>
<h3 id="Module局部状态"><a href="#Module局部状态" class="headerlink" title="Module局部状态"></a>Module局部状态</h3><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写.<br>我们在moduleA中添加state、mutations、getters<br>mutation和getters接收的第一个参数是局部状态对象<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/269.png" alt><br>注意:<br>虽然, 我们的doubleCount和increment都是定义在对象内部的.<br>但是在调用的时候, 依然是通过this.$store来直接调用的.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/270.png" alt></p>
<h3 id="Actions的写法"><a href="#Actions的写法" class="headerlink" title="Actions的写法"></a>Actions的写法</h3><p>actions的写法呢? 接收一个context参数对象<br>局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/271.png" alt><br>如果getters中也需要使用全局的状态, 可以接受更多的参数<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/272.png" alt></p>
<h2 id="项目结构组织"><a href="#项目结构组织" class="headerlink" title="项目结构组织"></a>项目结构组织</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>当我们的Vuex帮助我们管理过多的内容时, 好的项目结构可以让我们的代码更加清晰.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/273.png" alt></p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="认识Promise"><a href="#认识Promise" class="headerlink" title="认识Promise"></a>认识Promise</h2><h3 id="什么是Promise呢？"><a href="#什么是Promise呢？" class="headerlink" title="什么是Promise呢？"></a>什么是Promise呢？</h3><p>ES6中一个非常重要和好用的特性就是Promise<br>但是初次接触Promise会一脸懵逼，这TM是什么东西？<br>看看官方或者一些文章对它的介绍和用法，也是一头雾水。<br>Promise到底是做什么的呢？<br><strong>Promise是异步编程的一种解决方案。</strong><br>那什么时候我们会来处理异步事件呢？<br>一种很常见的场景应该就是网络请求了。<br>我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像简单的3+4=7一样将结果返回。<br>所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去。<br>如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦。<br>但是，当网络请求非常复杂时，就会出现回调地狱。<br>OK，我以一个非常夸张的案例来说明。</p>
<h3 id="网络请求的回调地狱"><a href="#网络请求的回调地狱" class="headerlink" title="网络请求的回调地狱"></a>网络请求的回调地狱</h3><p>我们来考虑下面的场景(有夸张的成分)：<br>我们需要通过一个url1从服务器加载一个数据data1，data1中包含了下一个请求的url2<br>我们需要通过data1取出url2，从服务器加载数据data2，data2中包含了下一个请求的url3<br>我们需要通过data2取出url3，从服务器加载数据data3，data3中包含了下一个请求的url4<br>发送网络请求url4，获取最终的数据data4<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/274.png" alt><br>上面的代码有什么问题吗？<br>正常情况下，不会有什么问题，可以正常运行并且获取我们想要的结果。<br>但是，这样额代码难看而且不容易维护。<br>我们更加期望的是一种更加优雅的方式来进行这种异步操作。<br>如何做呢？就是使用Promise。<br>Promise可以以一种非常优雅的方式来解决这个问题。</p>
<h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><h3 id="定时器的异步事件"><a href="#定时器的异步事件" class="headerlink" title="定时器的异步事件"></a>定时器的异步事件</h3><p>我们先来看看Promise最基本的语法。<br>这里，我们用一个定时器来模拟异步事件：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/275.png" alt><br>假设下面的data是从网络上1秒后请求的数据<br>console.log就是我们的处理方式。<br>这是我们过去的处理方式，我们将它换成Promise代码<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/276.png" alt><br>这个例子会让我们感觉脱裤放屁，多此一举<br>首先，下面的Promise代码明显比上面的代码看起来还要复杂。<br>其次，下面的Promise代码中包含的resolve、reject、then、catch都是些什么东西？<br>我们先不管第一个复杂度的问题，因为这样的一个屁大点的程序根本看不出来Promise真正的作用。</p>
<h3 id="定时器异步事件解析"><a href="#定时器异步事件解析" class="headerlink" title="定时器异步事件解析"></a>定时器异步事件解析</h3><p>我们先来认认真真的读一读这个程序到底做了什么？<br>new Promise很明显是创建一个Promise对象<br>小括号中((resolve, reject) =&gt; {})也很明显就是一个函数，而且我们这里用的是之前刚刚学习过的箭头函数。<br>但是resolve, reject它们是什么呢？<br>我们先知道一个事实：在创建Promise时，传入的这个箭头函数是固定的（一般我们都会这样写）<br>resolve和reject它们两个也是函数，通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。<br>成功还是失败？<br>如果是成功的，那么通常我们会调用resolve(messsage)，这个时候，我们后续的then会被回调。<br>如果是失败的，那么通常我们会调用reject(error)，这个时候，我们后续的catch会被回调。<br>OK，这就是Promise最基本的使用了。</p>
<h3 id="Promise三种状态"><a href="#Promise三种状态" class="headerlink" title="Promise三种状态"></a>Promise三种状态</h3><p>首先, 当我们开发中有异步操作时, 就可以给异步操作包装一个Promise<br>异步操作之后会有三种状态<br>我们一起来看一下这三种状态:<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/277.png" alt><br>pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。<br>fulfill：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()<br>reject：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/278.png" alt></p>
<h2 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h2><h3 id="Promise链式调用-1"><a href="#Promise链式调用-1" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><p>我们在看Promise的流程图时，发现无论是then还是catch都可以返回一个Promise对象。<br>所以，我们的代码其实是可以进行链式调用的：<br>这里我们直接通过Promise包装了一下新的数据，将Promise对象返回了<br>Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数<br>Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/279.png" alt></p>
<h3 id="链式调用简写"><a href="#链式调用简写" class="headerlink" title="链式调用简写"></a>链式调用简写</h3><p>简化版代码：<br>如果我们希望数据直接包装成Promise.resolve，那么在then中可以直接返回数据<br>注意下面的代码中，我讲return Promise.resovle(data)改成了return data<br>结果依然是一样的<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/280.png" alt></p>
<h1 id="网络模块封装"><a href="#网络模块封装" class="headerlink" title="网络模块封装"></a>网络模块封装</h1><h2 id="模块的选择"><a href="#模块的选择" class="headerlink" title="模块的选择"></a>模块的选择</h2><h3 id="选择什么网络模块"><a href="#选择什么网络模块" class="headerlink" title="选择什么网络模块?"></a>选择什么网络模块?</h3><p>Vue中发送网络请求有非常多的方式, 那么, 在开发中, 如何选择呢?<br><strong>选择一</strong>: 传统的Ajax是基于XMLHttpRequest(XHR)<br>为什么不用它呢?<br>非常好解释, 配置和调用方式等非常混乱.<br>编码起来看起来就非常蛋疼.<br>所以真实开发中很少直接使用, 而是使用jQuery-Ajax<br><strong>选择二:</strong> 在前面的学习中, 我们经常会使用jQuery-Ajax<br>相对于传统的Ajax非常好用.<br>为什么不选择它呢?<br>首先, 我们先明确一点: 在Vue的整个开发中都是不需要使用jQuery了.<br>那么, 就意味着为了方便我们进行一个网络请求, 特意引用一个jQuery, 你觉得合理吗?<br>jQuery的代码1w+行.<br>Vue的代码才1w+行.<br>完全没有必要为了用网络请求就引用这个重量级的框架.<br><strong>选择三:</strong> 官方在Vue1.x的时候, 推出了Vue-resource.<br>Vue-resource的体积相对于jQuery小很多.<br>另外Vue-resource是官方推出的.<br>为什么不选择它呢?<br>在Vue2.0退出后, Vue作者就在GitHub的Issues中说明了去掉vue-resource, 并且以后也不会再更新.<br>那么意味着以后vue-reource不再支持新的版本时, 也不会再继续更新和维护.<br>对以后的项目开发和维护都存在很大的隐患.<br><strong>选择四:</strong>在说明不再继续更新和维护vue-resource的同时, 作者还推荐了一个框架: axios为什么不用它呢?<br>axios有非常多的优点, 并且用起来也非常方便.<br>稍后, 我们对他详细学习.</p>
<h2 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>在前端开发中, 我们一种常见的网络请求方式就是JSONP<br>使用JSONP最主要的原因往往是为了解决跨域访问的问题.<br>JSONP的原理是什么呢?<br>JSONP的核心在于通过<code>&lt;script&gt;</code>标签的src来帮助我们请求数据.<br>原因是我们的项目部署在domain1.com服务器上时, 是不能直接访问domain2.com服务器上的资料的.<br>这个时候, 我们利用<code>&lt;script&gt;</code>标签的src帮助我们去服务器请求到数据, 将数据当做一个javascript的函数来执行, 并且执行的过程中传入我们需要的json.<br>所以, 封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称.<br>JSONP如何封装呢?<br>我们一起自己来封装一个处理JSONP的代码吧.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/281.png" alt></p>
<h3 id="JSONP封装"><a href="#JSONP封装" class="headerlink" title="JSONP封装"></a>JSONP封装</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/282.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/283.png" alt></p>
<h2 id="认识axios"><a href="#认识axios" class="headerlink" title="认识axios"></a>认识axios</h2><h3 id="为什么选择axios"><a href="#为什么选择axios" class="headerlink" title="为什么选择axios?"></a>为什么选择axios?</h3><p>为什么选择axios? 作者推荐和功能特点<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/284.png" alt><br>功能特点:<br>在浏览器中发送 XMLHttpRequests 请求<br>在 node.js 中发送 http请求<br>支持 Promise API<br>拦截请求和响应<br>转换请求和响应数据<br>等等<br>补充: axios名称的由来? 个人理解<br>没有具体的翻译.<br>axios: ajax i/o system.</p>
<h3 id="axiox请求方式"><a href="#axiox请求方式" class="headerlink" title="axiox请求方式"></a>axiox请求方式</h3><p>支持多种请求方式:</p>
<ul>
<li>axios(config)</li>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<p>如何发送请求呢?<br>我们看一下下面的案例</p>
<h2 id="发送基本请求"><a href="#发送基本请求" class="headerlink" title="发送基本请求"></a>发送基本请求</h2><h3 id="发送get请求演示"><a href="#发送get请求演示" class="headerlink" title="发送get请求演示"></a>发送get请求演示</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/285.png" alt></p>
<h3 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h3><p>有时候, 我们可能需求同时发送两个请求<br>使用axios.all, 可以放入多个请求的数组.<br>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/286.png" alt></p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在上面的示例中, 我们的BaseURL是固定的<br>事实上, 在开发中可能很多参数都是固定的.<br>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL &#x3D; ‘123.207.32.32:8000’axios.defaults.headers.post[‘Content-Type’] &#x3D; ‘application&#x2F;x-www-form-urlencoded’;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/287.png" alt></p>
<h3 id="常见的配置选项"><a href="#常见的配置选项" class="headerlink" title="常见的配置选项"></a>常见的配置选项</h3><p>请求地址<br>url: ‘/user’,<br>请求类型<br>method: ‘get’,<br>请根路径<br>baseURL: ‘<a href="http://www.mt.com/api&#39;" target="_blank" rel="noopener">http://www.mt.com/api&#39;</a>,<br>请求前的数据处理<br>transformRequest:[function(data){}],<br>请求后的数据处理<br>transformResponse: [function(data){}],<br>自定义的请求头<br>headers:{‘x-Requested-With’:’XMLHttpRequest’},<br>URL查询对象<br>params:{ id: 12 },<br>查询对象序列化函数<br>paramsSerializer: function(params){ }<br>request body<br>data: { key: ‘aa’},<br>超时设置s<br>timeout: 1000,<br>跨域是否带Token<br>withCredentials: false,<br>自定义请求处理<br>adapter: function(resolve, reject, config){},<br>身份验证信息<br>auth: { uname: ‘’, pwd: ‘12’},<br>响应的数据格式 json / blob /document /arraybuffer / text / stream<br>responseType: ‘json’,</p>
<h2 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h2><h3 id="axios的实例"><a href="#axios的实例" class="headerlink" title="axios的实例"></a>axios的实例</h3><p>为什么要创建axios的实例呢?<br>当我们从axios模块中导入对象时, 使用的实例是默认的实例.<br>当给该实例设置一些默认配置时, 这些配置就被固定下来了.<br>但是后续开发中, 某些配置可能会不太一样.<br>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等.<br>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/288.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/289.png" alt></p>
<h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><p><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/290.png" alt></p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="如何使用拦截器？"><a href="#如何使用拦截器？" class="headerlink" title="如何使用拦截器？"></a>如何使用拦截器？</h3><p>axios提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。<br>如何使用拦截器呢？<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/291.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/292.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/293.png" alt></p>
<h3 id="请求拦截器中都做什么呢？"><a href="#请求拦截器中都做什么呢？" class="headerlink" title="请求拦截器中都做什么呢？"></a>请求拦截器中都做什么呢？</h3><p>请求拦截可以做到的事情：<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/294.png" alt><br>请求拦截中错误拦截较少，通常都是配置相关的拦截<br>可能的错误比如请求超时，可以将页面跳转到一个错误页面中。</p>
<h3 id="响应拦截器中都做什么呢？"><a href="#响应拦截器中都做什么呢？" class="headerlink" title="响应拦截器中都做什么呢？"></a>响应拦截器中都做什么呢？</h3><p>响应拦截中完成的事情：<br>响应的成功拦截中，主要是对数据进行过滤。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/295.png" alt><br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/296.png" alt><br>响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。<br><img src="/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/297.png" alt></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SearchFor</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://yoursite.com/2020/03/30/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">SearchFor's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/05/js%E8%AF%AD%E6%B3%95/"><i class="fa fa-chevron-left">  </i><span>js语法</span></a></div><div class="next-post pull-right"><a href="/2020/03/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"><span>从零开始搭建自己的个人博客</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://img.1ppt.com/uploads/allimg/1910/1_191025201728_1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By SearchFor</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>